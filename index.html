<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="JPDB Reader">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#3b82f6">
    <meta name="description" content="Japanese reading and learning tool with JPDB integration, optimized for iPad">
    <meta name="keywords" content="Japanese, reading, learning, JPDB, vocabulary, iPad, tablet">
    <meta name="author" content="JPDB Reader">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png">

    <!-- Preload critical resources -->
    <link rel="preload" href="/demo.html" as="document">
    <link rel="dns-prefetch" href="//jpdb.io">
    <link rel="dns-prefetch" href="//cdn.tailwindcss.com">

    <title>JPDB Japanese Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load JSZip for manual EPUB parsing -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Load PDF.js for PDF rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- OCR functionality will use OCR.space API -->
    <style>
        .vocab-highlight {
            cursor: pointer;
            padding: 1px 2px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
            transition: opacity 0.2s;
        }
        .vocab-highlight:hover {
            opacity: 0.8;
        }
        .vocab-new { background-color: #e0f2fe; }
        .vocab-learning { background-color: #fed7aa; }
        .vocab-known { background-color: #d9f99d; }
        .vocab-not-in-deck { background-color: #fce7f3; }
        .vocab-locked { background-color: #f3e8ff; }
        .vocab-redundant { background-color: #fef3c7; opacity: 0.7; }
        .vocab-failed { background-color: #fecaca; }
        .vocab-suspended { background-color: #f1f5f9; text-decoration: line-through; }
        .vocab-blacklisted { background-color: #f9fafb; color: #6b7280; }

        /* Manga OCR Overlay Styles */
        .ocr-overlay {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
        }

        .ocr-text-bubble {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #3b82f6;
            padding: 4px 8px;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 300px;
        }

        .ocr-text-bubble:hover {
            background: rgba(255, 255, 255, 0.98);
            border-color: #2563eb;
        }

        .ocr-selection {
            position: absolute;
            border: 2px solid #ef4444;
            background: rgba(239, 68, 68, 0.1);
            pointer-events: none;
            z-index: 5;
        }

        .manga-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 20;
        }

        .manga-loading-content {
            text-align: center;
            color: white;
        }

        .manga-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .vocab-due { background-color: #d1fae5; border: 2px solid #10b981; }
        .vocab-never-forget { background-color: #d9f99d; border: 2px solid #16a34a; }

        .vocab-particle {
            background-color: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
        }

        .vocab-grammar {
            background-color: #fef3c7;
            color: #92400e;
            border: 1px solid #f59e0b;
            font-style: italic;
        }

        .parsed-text {
            background-color: #f8fafc;
            border-left: 4px solid #10b981;
            padding: 1rem;
            border-radius: 0 4px 4px 0;
        }

        .parsed-text .vocab-highlight,
        .parsed-text .vocab-particle,
        .parsed-text .vocab-grammar {
            font-weight: 600;
            margin: 0 1px;
        }

        .vocab-popup {
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid #e5e7eb;
        }

        /* JPDB-style classes for EPUB reader */
        .jpdb-word {
            cursor: pointer;
            border-radius: 2px;
            padding: 1px 2px;
            border: 1px solid rgba(0,0,0,0.1);
            display: inline;
        }

        .jpdb-word.new {
            background-color: #fef3c7 !important;
        }

        .jpdb-word.learning {
            background-color: #fed7aa !important;
        }

        .jpdb-word.known {
            background-color: #d9f99d !important;
        }

        .jpdb-word.not-in-deck {
            background-color: #e0f2fe !important;
        }

        .jpdb-word.locked {
            background-color: #f3e8ff !important;
        }

        .jpdb-word.redundant {
            background-color: #fef3c7 !important;
            opacity: 0.7;
        }

        .jpdb-word.failed {
            background-color: #fecaca !important;
        }

        .jpdb-word.suspended {
            background-color: #f1f5f9 !important;
            text-decoration: line-through;
        }

        .jpdb-word.blacklisted {
            background-color: #f9fafb !important;
            color: #6b7280;
        }

        .jpdb-word.due {
            background-color: #dbeafe !important;
            border: 2px solid #3b82f6 !important;
        }

        .jpdb-word.never-forget {
            background-color: #d9f99d !important;
            border: 2px solid #16a34a !important;
        }

        /* Tab and Collapsible Styles */
        .tab-btn {
            padding: 1rem 2rem;
            border-radius: 1rem;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 1.125rem;
        }
        .tab-btn:not(.active) {
            background: #f3f4f6;
            color: #6b7280;
        }
        .tab-btn.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
        }
        .tab-btn:not(.active):hover {
            background: #e5e7eb;
            transform: translateY(-2px);
        }
        .tab-content { 
            display: none; 
        }
        .tab-content.active { 
            display: block !important; 
            opacity: 1 !important;
            animation: fadeIn 0.3s;
        }
        .tab-content.hidden {
            display: none !important;
        }
        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Toast Styles */
        .toast {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Button Enhancements */
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Responsive Tabs */
        @media (max-width: 768px) {
            .tab-btn {
                padding: 0.75rem 1rem;
                font-size: 0.875rem;
                flex: 1;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Vibrant Header -->
        <header class="bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 text-white py-12 rounded-2xl shadow-2xl mb-12 text-center">
            <h1 class="text-5xl font-bold mb-3">üéå JPDB Japanese Reader</h1>
            <p class="text-xl opacity-90">Your encouraging companion for Japanese learning</p>
        </header>

        <!-- Settings Section (Collapsible) -->
        <div class="bg-gradient-to-r from-gray-50 to-blue-50 rounded-2xl shadow-lg p-8 mb-12">
            <button onclick="toggleSettings()" class="w-full flex justify-between items-center hover:scale-105 transition-transform duration-300">
                <h2 class="text-3xl font-bold text-gray-800">‚öôÔ∏è Settings</h2>
                <span id="settingsChevron" class="text-4xl transition-transform duration-300">‚ñº</span>
            </button>
            <div id="settingsContent" class="mt-6 space-y-6">
                <div>
                    <label class="block text-base font-medium text-gray-700 mb-2">JPDB API Key</label>
                    <div class="flex gap-3">
                        <input
                            type="password"
                            id="apiKey"
                            placeholder="Enter your JPDB API key"
                            class="flex-1 px-4 py-3 text-base border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                        >
                        <button
                            onclick="saveApiKey()"
                            class="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üíæ Save
                        </button>
                        <button
                            onclick="testConnection()"
                            class="px-6 py-3 bg-gradient-to-r from-gray-500 to-gray-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üß™ Test
                        </button>
                    </div>
                </div>

                <!-- Deck Selection Section -->
                <div class="mt-6 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl border-2 border-blue-300">
                    <h3 class="text-xl font-bold text-blue-700 mb-3">üìö JPDB Deck Selection</h3>
                    <p class="text-base text-blue-600 mb-4">
                        Select a deck to automatically add vocabulary words when you click "Add to Deck".
                    </p>
                    <div class="space-y-3">
                        <button
                            onclick="loadUserDecks()"
                            class="w-full px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üîÑ Load My Decks
                        </button>
                        <div id="deckStatus" class="text-sm text-gray-600"></div>
                        <select
                            id="deckDropdown"
                            onchange="selectDeckFromDropdown(this.value)"
                            class="w-full px-4 py-3 text-base border-2 border-blue-400 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white"
                            disabled
                        >
                            <option value="">No decks loaded</option>
                        </select>
                    </div>
                    <div id="selectedDeck" class="mt-3 px-4 py-3 bg-white rounded-xl border-2 border-blue-400 text-base font-semibold shadow-md">
                        No deck selected
                    </div>
                </div>

                <!-- Cache Management Section -->
                <div class="mt-6 p-6 bg-gradient-to-r from-gray-50 to-orange-50 rounded-xl border-2 border-orange-300">
                    <h3 class="text-xl font-bold text-gray-700 mb-3">üóÑÔ∏è Cache Management</h3>
                    <p class="text-base text-gray-600 mb-4">
                        Clear cached JPDB parsing results and transcripts to test fresh API calls or free up storage.
                    </p>
                    <div class="flex gap-3">
                        <button
                            onclick="clearAllCaches()"
                            class="px-6 py-3 bg-gradient-to-r from-red-500 to-pink-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üóëÔ∏è Clear All Caches
                        </button>
                        <button
                            onclick="showCacheInfo()"
                            class="px-6 py-3 bg-gradient-to-r from-purple-500 to-blue-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üìä Cache Info
                        </button>
                    </div>
                </div>

                <!-- OCR API Key Section -->
                <div class="mt-6 p-6 bg-gradient-to-r from-orange-50 to-pink-50 rounded-xl border-2 border-orange-300">
                    <h3 class="text-xl font-bold text-gray-800 mb-3">üîç OCR.space API Key</h3>
                    <p class="text-base text-gray-600 mb-4">
                        Required for Manga Reader OCR functionality. Free tier: 300 requests/month. Get your API key at 
                        <a href="https://ocr.space/ocrapi" target="_blank" class="text-blue-600 underline font-semibold">ocr.space</a>
                    </p>
                    <div class="flex gap-3">
                        <input
                            type="password"
                            id="ocrApiKey"
                            placeholder="Enter your OCR.space API key (helloworld for free tier)"
                            class="flex-1 px-4 py-3 text-base border-2 border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all"
                        >
                        <button
                            onclick="saveOcrApiKey()"
                            class="px-6 py-3 bg-gradient-to-r from-orange-500 to-pink-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üíæ Save
                        </button>
                        <button
                            onclick="testOcrConnection()"
                            class="px-6 py-3 bg-gradient-to-r from-gray-500 to-gray-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üß™ Test
                        </button>
                    </div>
                </div>

                <div id="connectionStatus" class="mt-6"></div>

                <div class="text-base text-gray-600 p-4 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-xl">
                    <p class="mb-3 font-bold text-lg"><strong>‚ú® How to get your API key:</strong></p>
                    <ol class="list-decimal list-inside space-y-2 ml-2">
                        <li>Go to <a href="https://jpdb.io" target="_blank" class="text-blue-500 underline font-semibold">jpdb.io</a></li>
                        <li>Log in to your account</li>
                        <li>Go to Settings ‚Üí API</li>
                        <li>Generate or copy your API key</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- Feature Sections (Collapsible Dropdowns) -->
        
        <!-- Video Player Section -->
        <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl shadow-lg p-8 mb-12 border-2 border-blue-300">
            <button onclick="toggleSection('video')" class="w-full flex justify-between items-center hover:scale-105 transition-transform duration-300">
                <h2 class="text-3xl font-bold text-gray-800">üé¨ Video Player + Subtitles</h2>
                <span id="videoChevron" class="text-4xl transition-transform duration-300">‚ñº</span>
            </button>
            <div id="videoContent" class="mt-6 space-y-6 hidden">
                <!-- Video File Input -->
                <div>
                    <label class="block text-base font-semibold text-gray-700 mb-3">üéûÔ∏è Video File</label>
                    <input
                        type="file"
                        id="videoFile"
                        accept="video/*"
                        class="block w-full text-base text-gray-500 file:mr-4 file:py-3 file:px-6 file:rounded-xl file:border-0 file:text-base file:font-semibold file:bg-gradient-to-r file:from-blue-50 file:to-purple-50 file:text-blue-700 hover:file:bg-blue-100"
                    >
                </div>

                <!-- Subtitle File Input -->
                <div>
                    <label class="block text-base font-semibold text-gray-700 mb-3">üìù Subtitle File (.srt, .vtt)</label>
                    <input
                        type="file"
                        id="subtitleFile"
                        accept=".srt,.vtt,text/srt,text/vtt"
                        class="block w-full text-base text-gray-500 file:mr-4 file:py-3 file:px-6 file:rounded-xl file:border-0 file:text-base file:font-semibold file:bg-gradient-to-r file:from-green-50 file:to-emerald-50 file:text-green-700 hover:file:bg-green-100"
                    >
                </div>

                <!-- Video Controls -->
                <div class="flex gap-4 flex-wrap">
                    <button id="loadVideoBtn" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300">
                        üìπ Load Video
                    </button>
                    <button id="playPauseBtn" class="px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                        ‚ñ∂Ô∏è Play
                    </button>
                    <span id="videoStatus" class="px-6 py-3 bg-gradient-to-r from-gray-100 to-gray-200 text-gray-700 rounded-xl text-base font-semibold shadow-md">
                        Ready
                    </span>
                </div>

                <!-- Video Player Container -->
                <div id="videoContainer" class="border-2 border-dashed border-gray-300 rounded-xl p-6 bg-gradient-to-br from-gray-50 to-blue-50 min-h-[300px] hidden shadow-lg">
                    <div class="flex gap-4">
                        <!-- Video Section -->
                        <div class="flex-1 relative">
                            <video id="videoPlayer" class="w-full max-h-[60vh] bg-black rounded" controls></video>

                            <!-- Subtitle Overlay -->
                            <div id="subtitleOverlay" class="absolute bottom-16 left-0 right-0 text-center text-white text-xl font-bold drop-shadow-lg pointer-events-none hidden">
                                <div id="subtitleText" class="bg-black bg-opacity-75 rounded px-4 py-2 inline-block"></div>
                            </div>
                        </div>

                        <!-- Transcript Section (Right Side) -->
                        <div id="transcriptContainer" class="w-80 border-2 border-dashed border-blue-300 rounded-lg p-3 bg-blue-50 hidden">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="text-sm font-semibold text-blue-700">Transcript</h4>
                                <div class="flex gap-1">
                                    <button id="generateTranscriptBtn" class="bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition-colors hidden">
                                        üìù Parse
                                    </button>
                                    <button id="autoScrollBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs transition-colors">
                                        üîÑ Auto
                                    </button>
                                    <button id="searchTranscriptBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs transition-colors">
                                        üîç
                                    </button>
                                </div>
                            </div>

                            <div id="transcriptContent" class="max-h-[400px] overflow-y-auto text-xs leading-relaxed">
                                <!-- Transcript will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Manga Reader Section -->
        <div class="bg-gradient-to-r from-green-50 to-emerald-50 rounded-2xl shadow-lg p-8 mb-12 border-2 border-green-300">
            <button onclick="toggleSection('manga')" class="w-full flex justify-between items-center hover:scale-105 transition-transform duration-300">
                <h2 class="text-3xl font-bold text-gray-800">üñºÔ∏è Manga Reader (PDF + OCR)</h2>
                <span id="mangaChevron" class="text-4xl transition-transform duration-300">‚ñº</span>
            </button>
            <div id="mangaContent" class="mt-6 space-y-6 hidden">
                <p class="text-gray-600 mb-8 text-lg">Upload PDF files for OCR text extraction and JPDB vocabulary highlighting</p>
                
                <!-- File Upload -->
                <div>
                    <label class="block text-base font-semibold text-gray-700 mb-3">üìÅ Select PDF File</label>
                    <input type="file" id="mangaFile" accept=".pdf" class="block w-full text-base text-gray-500 file:mr-4 file:py-3 file:px-6 file:rounded-xl file:border-0 file:text-base file:font-semibold file:bg-gradient-to-r file:from-green-50 file:to-emerald-50 file:text-green-700 hover:file:bg-green-100">
                </div>

                <!-- Reader Controls -->
                <div class="flex gap-4 flex-wrap">
                    <button id="loadMangaBtn" class="px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300 relative">
                        <span id="loadMangaText">üìñ Load Manga</span>
                        <div id="loadMangaSpinner" class="hidden ml-2 inline-block animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                    </button>
                    <div class="flex gap-3">
                        <button id="prevMangaPageBtn" class="px-4 py-3 bg-gradient-to-r from-gray-400 to-gray-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            ‚¨ÖÔ∏è Page
                        </button>
                        <span id="mangaPageIndicator" class="px-4 py-3 bg-gradient-to-r from-gray-100 to-gray-200 text-gray-700 rounded-xl min-w-[120px] text-center text-base font-semibold shadow-md">
                            Ready
                        </span>
                        <button id="nextMangaPageBtn" class="px-4 py-3 bg-gradient-to-r from-gray-400 to-gray-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            ‚û°Ô∏è Page
                        </button>
                    </div>
                    <div class="flex gap-3">
                        <button id="zoomOutBtn" class="px-4 py-3 bg-gradient-to-r from-purple-400 to-purple-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            üîç-
                        </button>
                        <span id="zoomIndicator" class="px-4 py-3 bg-gradient-to-r from-purple-100 to-purple-200 text-purple-700 rounded-xl min-w-[80px] text-center text-base font-semibold shadow-md">
                            100%
                        </span>
                        <button id="zoomInBtn" class="px-4 py-3 bg-gradient-to-r from-purple-400 to-purple-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            üîç+
                        </button>
                        <button id="resetZoomBtn" class="px-4 py-3 bg-gradient-to-r from-purple-300 to-purple-400 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            Reset
                        </button>
                    </div>
                </div>

                <!-- Manga Display Area -->
                <div id="mangaDisplay" class="border-2 border-dashed border-gray-300 rounded-xl p-6 text-center bg-gradient-to-br from-gray-50 to-green-50 min-h-[400px] hidden shadow-lg">
                    <div class="relative inline-block">
                        <canvas id="mangaCanvas" class="max-w-full max-h-[60vh] border shadow-sm bg-white mx-auto"></canvas>
                        <!-- OCR Region Selection Overlay -->
                        <div id="ocrOverlay" class="absolute top-0 left-0 pointer-events-none">
                            <canvas id="selectionCanvas" class="absolute top-0 left-0 pointer-events-auto cursor-crosshair"></canvas>
                        </div>
                    </div>

                    <!-- OCR Controls -->
                    <div id="ocrControls" class="mt-4 flex gap-2 justify-center hidden">
                        <button id="selectRegionBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded-lg transition-colors text-sm">
                            üéØ Select Region
                        </button>
                        <button id="clearOverlaysBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg transition-colors text-sm">
                            üóëÔ∏è Clear Overlays
                        </button>
                        <span id="selectionStatus" class="px-3 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm">
                            Ready to select region
                        </span>
                    </div>
                </div>

                <!-- OCR Results Display Area -->
                <div id="ocrResultsDisplay" class="mt-4 border-2 border-dashed border-blue-300 rounded-lg p-4 bg-blue-50 min-h-[150px] hidden">
                    <h3 class="text-lg font-semibold text-blue-800 mb-2">üìù OCR Results</h3>
                    <div id="ocrResultsContent" class="text-black whitespace-pre-wrap text-sm leading-relaxed max-h-[300px] overflow-y-auto">
                        <!-- OCR results with JPDB highlighting will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- EPUB Reader Section -->
        <div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-2xl shadow-lg p-8 mb-12 border-2 border-indigo-300">
            <button onclick="toggleSection('epub')" class="w-full flex justify-between items-center hover:scale-105 transition-transform duration-300">
                <h2 class="text-3xl font-bold text-gray-800">üìö EPUB Reader</h2>
                <span id="epubChevron" class="text-4xl transition-transform duration-300">‚ñº</span>
            </button>
            <div id="epubContent" class="mt-6 space-y-6 hidden">
                <p class="text-gray-600 mb-8 text-lg">Upload and read EPUB files with integrated JPDB vocabulary highlighting</p>

                <!-- File Upload -->
                <div>
                    <label class="block text-base font-semibold text-gray-700 mb-3">üìÅ Select EPUB File</label>
                    <input type="file" id="epubFile" accept=".epub" class="block w-full text-base text-gray-500 file:mr-4 file:py-3 file:px-6 file:rounded-xl file:border-0 file:text-base file:font-semibold file:bg-gradient-to-r file:from-blue-50 file:to-purple-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>

                <!-- Reader Controls -->
                <div class="flex gap-4 flex-wrap">
                    <button id="loadEpubBtn" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300">
                        üìñ Load EPUB
                    </button>
                    <div class="flex gap-3">
                        <button id="prevChapterBtn" class="px-4 py-3 bg-gradient-to-r from-gray-500 to-gray-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            ‚¨ÖÔ∏è Chapter
                        </button>
                        <button id="prevPageBtn" class="px-4 py-3 bg-gradient-to-r from-gray-400 to-gray-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            ‚¨ÖÔ∏è Page
                        </button>
                        <span id="pageIndicator" class="px-4 py-3 bg-gradient-to-r from-gray-100 to-gray-200 text-gray-700 rounded-xl min-w-[120px] text-center text-base font-semibold shadow-md">
                            Ready
                        </span>
                        <button id="nextPageBtn" class="px-4 py-3 bg-gradient-to-r from-gray-400 to-gray-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            Page ‚û°Ô∏è
                        </button>
                        <button id="nextChapterBtn" class="px-4 py-3 bg-gradient-to-r from-gray-500 to-gray-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300" disabled>
                            Chapter ‚û°Ô∏è
                        </button>
                    </div>
                </div>

                <!-- Progress -->
                <div class="text-sm text-gray-600">
                    <span id="readingProgress">Ready to load EPUB file</span>
                </div>

                <!-- Reader Display -->
                <div id="epubReader" class="border-2 border-gray-300 rounded-xl bg-gradient-to-br from-gray-50 to-blue-50 min-h-[600px] max-h-[800px] overflow-auto shadow-lg">
                    <div class="p-12 text-center text-gray-500 text-lg">
                        Load an EPUB file to start reading
                    </div>
                </div>
            </div>
        </div>

        <!-- Sentence Parser Section -->
        <div class="bg-gradient-to-r from-yellow-50 to-orange-50 rounded-2xl shadow-lg p-8 mb-12 border-2 border-orange-300">
            <button onclick="toggleSection('text')" class="w-full flex justify-between items-center hover:scale-105 transition-transform duration-300">
                <h2 class="text-3xl font-bold text-gray-800">üìù Sentence Parser & Highlighting</h2>
                <span id="textChevron" class="text-4xl transition-transform duration-300">‚ñº</span>
            </button>
            <div id="textContent" class="mt-6 space-y-6 hidden">
                <div>
                    <label class="block text-base font-semibold text-gray-700 mb-3">Japanese Text</label>
                    <div class="flex gap-3 mb-3">
                        <button
                            onclick="loadSampleText()"
                            class="px-6 py-3 bg-gradient-to-r from-yellow-400 to-orange-500 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                        >
                            üìÑ Load Sample Text
                        </button>
                        <span class="text-base text-gray-600 self-center">Try sample text with known vocabulary</span>
                    </div>
                    <textarea
                        id="japaneseText"
                        rows="5"
                        class="w-full px-4 py-3 text-base border-2 border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                        placeholder="Enter Japanese text to parse and highlight..."
                    >Áü•„Å£„Å¶„Çã„Åã„É™„É≥„Ç¥„Åó„ÅãÈ£ü„Åπ„Å™„ÅÑ</textarea>
                </div>

                <div class="flex gap-3">
                    <button
                        onclick="parseAndHighlight()"
                        class="px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                    >
                        ‚ú® Parse & Highlight
                    </button>
                    <button
                        onclick="showRawResponse()"
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-base font-semibold rounded-xl shadow-lg hover:shadow-2xl hover:scale-105 transition-all duration-300"
                    >
                        üîç Show Raw Response
                    </button>
                </div>

                <div id="highlightedText" class="border-2 border-gray-300 rounded-xl p-6 min-h-[150px] bg-gradient-to-br from-gray-50 to-blue-50">
                    <p class="text-gray-500 italic text-base">Parsed text with vocabulary highlighting will appear here...</p>
                    <p class="text-sm text-gray-400 mt-2">Text will be styled with a green left border once parsed</p>
                    <p class="text-sm text-blue-600 mt-3 bg-blue-100 p-3 rounded-lg">Note: Punctuation cleaned for parsing. Japanese vocabulary and katakana highlighted in context.</p>
                </div>

                <!-- Color Legend -->
                <div class="bg-gradient-to-br from-indigo-50 to-purple-50 rounded-2xl p-8 border-2 border-purple-300">
                    <h2 class="text-3xl font-bold mb-6 text-gray-800">üé® Color Legend</h2>
                    <div class="grid grid-cols-3 gap-4 mb-4">
                        <div>
                            <h3 class="font-medium mb-2">Vocabulary Words:</h3>
                            <div class="space-y-2">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-new"></div>
                                    <span class="text-sm">New</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-learning"></div>
                                    <span class="text-sm">Learning</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-known"></div>
                                    <span class="text-sm">Known</span>
                                </div>
                            </div>
                        </div>
                        <div>
                            <h3 class="font-medium mb-2">Grammar Elements:</h3>
                            <div class="space-y-2">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-particle"></div>
                                    <span class="text-sm">Particles („ÅØ, „Åå, „Çí, etc.)</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-grammar" style="font-style: italic;">„Å™„ÅÑ</div>
                                    <span class="text-sm">Grammar forms</span>
                                </div>
                            </div>
                        </div>
                        <div>
                            <h3 class="font-medium mb-2">Other:</h3>
                            <div class="space-y-2">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded border vocab-katakana"></div>
                                    <span class="text-sm">Katakana (foreign words)</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-4 border-b-2 border-dotted border-gray-400"></div>
                                    <span class="text-sm">Unparsed text</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="text-base text-gray-600 bg-gradient-to-r from-blue-100 to-indigo-100 p-4 rounded-xl border-2 border-blue-300">
                        <strong>üí° Debug Info:</strong> Check browser console for detailed API response. Now distinguishes between main vocabulary, particles/grammar, and unparsed text.
                    </div>
                </div>
            </div>
        </div>

    <script>
        let apiKey = localStorage.getItem('jpdb-api-key') || '';
        let lastApiResponse = null;

        // EPUB Reader variables
        let currentEpub = null;
        let currentChapter = null;
        let epubRendition = null;
        let currentEpubFile = null;
        let currentBookId = null;
        let currentPage = 0;
        let totalPages = 0;
        let chapterPages = [];

        // Manga Reader variables
        let currentMangaFile = null;
        let mangaPages = [];
        let currentMangaPage = 0;
        let mangaZoom = 100;

        // OCR Region Selection variables
        let isSelectingRegion = false;
        let selectionStart = null;
        let currentSelection = null;
        let ocrOverlays = [];
        let canvasRect = null;

        // Global registry for vocabulary data
        let vocabDataRegistry = new Map();

        // OCR.space API for Japanese OCR
        let ocrApiKey = localStorage.getItem('ocr-space-api-key') || 'helloworld'; // Default to free tier

        // Video Player Variables
        let currentVideoFile = null;
        let currentSubtitleFile = null;
        let subtitleData = [];
        let currentSubtitleIndex = -1;
        let videoDuration = 0;
        let autoScrollEnabled = false;
        let transcriptParsed = false;

        // Caching
        const JPDB_CACHE_KEY = 'jpdb-parse-cache';
        const TRANSCRIPT_CACHE_KEY = 'transcript-cache';
        let jpdbCache = {};
        let transcriptCache = {};

        // Deck Management
        let userDecks = [];
        let selectedDeckId = localStorage.getItem('selected-jpdb-deck-id') || null;
        let selectedDeckName = localStorage.getItem('selected-jpdb-deck-name') || null;

        // Load saved API keys and cache on page load
        document.getElementById('apiKey').value = apiKey;
        document.getElementById('ocrApiKey').value = ocrApiKey;

        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
                tab.classList.add('hidden');
            });
            
            // Remove active from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            const selectedTab = document.getElementById(`tab-${tabName}`);
            if (selectedTab) {
                selectedTab.classList.remove('hidden');
                selectedTab.classList.add('active');
            }
            
            // Add active to clicked button
            const selectedBtn = document.getElementById(`tab-btn-${tabName}`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');
            }
            
            // Save preference
            localStorage.setItem('activeTab', tabName);
        }

        // Collapsible settings functionality
        function toggleSettings() {
            const content = document.getElementById('settingsContent');
            const chevron = document.getElementById('settingsChevron');
            
            if (!content || !chevron) return;
            
            const isOpen = !content.classList.contains('hidden');
            
            if (isOpen) {
                content.classList.add('hidden');
                chevron.textContent = '‚ñ∂';
                chevron.style.transform = 'rotate(-90deg)';
                localStorage.setItem('settingsCollapsed', 'true');
            } else {
                content.classList.remove('hidden');
                chevron.textContent = '‚ñº';
                chevron.style.transform = 'rotate(0deg)';
                localStorage.setItem('settingsCollapsed', 'false');
            }
        }

        // Collapsible section functionality
        function toggleSection(sectionName) {
            const content = document.getElementById(`${sectionName}Content`);
            const chevron = document.getElementById(`${sectionName}Chevron`);
            
            if (!content || !chevron) return;
            
            const isOpen = !content.classList.contains('hidden');
            
            if (isOpen) {
                content.classList.add('hidden');
                chevron.textContent = '‚ñ∂';
                chevron.style.transform = 'rotate(-90deg)';
                localStorage.setItem(`${sectionName}Collapsed`, 'true');
            } else {
                content.classList.remove('hidden');
                chevron.textContent = '‚ñº';
                chevron.style.transform = 'rotate(0deg)';
                localStorage.setItem(`${sectionName}Collapsed`, 'false');
            }
        }

        // Load saved tab and settings state on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Restore active tab
            const savedTab = localStorage.getItem('activeTab');
            if (savedTab) {
                switchTab(savedTab);
            }
            
            // Restore settings collapse state
            const settingsCollapsed = localStorage.getItem('settingsCollapsed');
            if (settingsCollapsed === 'true') {
                const content = document.getElementById('settingsContent');
                const chevron = document.getElementById('settingsChevron');
                if (content && chevron) {
                    content.classList.add('hidden');
                    chevron.textContent = '‚ñ∂';
                    chevron.style.transform = 'rotate(-90deg)';
                }
            }
        });

        // Toast notification function
        function showToast(message, type = 'info') {
            const colors = {
                success: 'from-green-400 to-emerald-500',
                error: 'from-red-400 to-pink-500',
                info: 'from-blue-400 to-purple-500'
            };
            
            const toast = document.createElement('div');
            toast.className = `fixed top-4 right-4 bg-gradient-to-r ${colors[type]} text-white px-6 py-4 rounded-xl shadow-2xl z-50 font-semibold text-lg`;
            toast.textContent = message;
            toast.style.transform = 'translateX(500px)';
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.transition = 'transform 0.3s ease-out';
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            setTimeout(() => {
                toast.style.transition = 'transform 0.3s ease-in';
                toast.style.transform = 'translateX(500px)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Load caches
        try {
            const savedJpdbCache = localStorage.getItem(JPDB_CACHE_KEY);
            if (savedJpdbCache) jpdbCache = JSON.parse(savedJpdbCache);

            const savedTranscriptCache = localStorage.getItem(TRANSCRIPT_CACHE_KEY);
            if (savedTranscriptCache) transcriptCache = JSON.parse(savedTranscriptCache);
        } catch (error) {
            console.warn('Error loading caches:', error);
        }

        // OCR.space API function for Japanese text recognition
        async function performOCRWithSpaceAPI(imageDataURL) {
            try {
                console.log('üîÑ Sending image to OCR.space API...');

                // Convert data URL to blob
                const response = await fetch(imageDataURL);
                const blob = await response.blob();

                // Create FormData for OCR.space API - following documentation exactly
                const formData = new FormData();
                formData.append('file', blob, 'ocr-image.png');
                formData.append('language', 'jpn'); // Japanese (3-letter code as per docs)
                formData.append('isOverlayRequired', 'false'); // No overlay needed for text-only
                formData.append('detectOrientation', 'true'); // Auto-rotate if needed
                formData.append('scale', 'true'); // Internal upscaling for better OCR
                formData.append('OCREngine', '1'); // Use Engine 1 (supports Japanese, fastest)

                // Debug: Log the parameters we're sending
                console.log('üì§ Sending to OCR.space API:', {
                    apikey: ocrApiKey.substring(0, 8) + '...', // Don't log full key
                    language: 'jpn',
                    isOverlayRequired: 'false',
                    detectOrientation: 'true',
                    scale: 'true',
                    OCREngine: '1',
                    fileSize: blob.size + ' bytes',
                    fileType: blob.type
                });

                // Make API request to OCR.space
                const apiResponse = await fetch(`https://api.ocr.space/parse/image`, {
                    method: 'POST',
                    headers: {
                        'apikey': ocrApiKey,
                    },
                    body: formData
                });

                if (!apiResponse.ok) {
                    throw new Error(`OCR.space API error: ${apiResponse.status}`);
                }

                const result = await apiResponse.json();

                // Debug: Log the full API response
                console.log('üîç OCR.space API full response:', result);
                console.log('üîç Response status:', apiResponse.status);
                console.log('üîç Response headers:', Object.fromEntries(apiResponse.headers.entries()));

                if (result.IsErroredOnProcessing) {
                    console.error('‚ùå OCR.space processing error:', result.ErrorMessage);
                    throw new Error(`OCR processing error: ${result.ErrorMessage?.join(', ')}`);
                }

                // Check if we have parsed results
                if (!result.ParsedResults || result.ParsedResults.length === 0) {
                    console.warn('‚ö†Ô∏è No parsed results in OCR.space response');
                    return '';
                }

                const firstResult = result.ParsedResults[0];

                // Check FileParseExitCode as per documentation
                const exitCode = firstResult.FileParseExitCode;
                if (exitCode !== 1) {
                    console.error('‚ùå OCR.space parsing failed:', {
                        exitCode: exitCode,
                        errorMessage: firstResult.ErrorMessage,
                        errorDetails: firstResult.ErrorDetails
                    });

                    // Map exit codes to meaningful messages
                    const exitCodeMessages = {
                        0: 'File not found',
                        '-10': 'OCR Engine Parse Error',
                        '-20': 'Timeout',
                        '-30': 'Validation Error',
                        '-99': 'Unknown Error'
                    };

                    throw new Error(`OCR parsing failed: ${exitCodeMessages[exitCode] || 'Unknown error'} (${exitCode})`);
                }

                // Extract text from OCR.space response
                const ocrText = firstResult.ParsedText?.trim() || '';

                console.log('‚úÖ OCR.space API successful:', {
                    text: JSON.stringify(ocrText),
                    length: ocrText.length,
                    exitCode: exitCode,
                    hasOverlay: firstResult.TextOverlay?.HasOverlay || false,
                    ocrExitCode: result.OCRExitCode,
                    processingTime: result.ProcessingTimeInMilliseconds + 'ms'
                });

                return ocrText;

            } catch (error) {
                console.error('‚ùå OCR.space API failed:', error);
                throw error;
            }
        }

        // Test OCR.space API availability
        async function testOCRAPI() {
            try {
                console.log('üîÑ Testing OCR.space API...');
                // Simple test with a minimal image won't work well, but tests connectivity
                console.log('‚úÖ OCR.space API ready for use');
                return true;
            } catch (error) {
                console.error('‚ùå OCR.space API test failed:', error);
                return false;
            }
        }

        // Initialize OCR system
        testOCRAPI();

        async function saveApiKey() {
            const keyInput = document.getElementById('apiKey');
            apiKey = keyInput.value.trim();

            if (apiKey) {
                localStorage.setItem('jpdb-api-key', apiKey);
                showStatus('JPDB API key saved!', 'success');
            } else {
                showStatus('Please enter a JPDB API key', 'error');
            }
        }


        async function testConnection() {
            if (!apiKey) {
                showStatus('Please enter and save an API key first', 'error');
                return;
            }

            try {
                showStatus('Testing connection...', 'info');

                const response = await fetch('https://jpdb.io/api/v1/ping', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    showStatus('Connection successful! ‚úì', 'success');
                } else {
                    showStatus(`Connection failed: ${response.status}`, 'error');
                }
            } catch (error) {
                showStatus(`Connection error: ${error.message}`, 'error');
            }
        }


        async function parseAndHighlight() {
            const originalText = document.getElementById('japaneseText').value.trim();

            if (!originalText) {
                showStatus('Please enter some Japanese text', 'error');
                return;
            }

            if (!apiKey) {
                showStatus('Please enter and save an API key first', 'error');
                return;
            }

            try {
                showStatus('Parsing text...', 'info');

                console.log('Parsing text:', `"${originalText}"`);

                const response = await fetch('https://jpdb.io/api/v1/parse', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: originalText,
                        token_fields: ['vocabulary_index', 'position', 'length', 'furigana'],
                        vocabulary_fields: ['vid', 'sid', 'rid', 'spelling', 'reading', 'frequency_rank', 'part_of_speech', 'meanings_chunks', 'meanings_part_of_speech', 'card_state', 'pitch_accent'],
                        position_length_encoding: 'utf16'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error_message || data.error);
                }

                console.log('API Response:', data);
                console.log('Vocabulary data structure check:');
                if (data.vocabulary && data.vocabulary.length > 0) {
                    console.log('First vocab entry:', data.vocabulary[0]);
                    console.log('Array length:', data.vocabulary[0].length);
                    console.log('Field mapping:');
                    console.log('  [0] vid:', data.vocabulary[0][0]);
                    console.log('  [1] sid:', data.vocabulary[0][1]);
                    console.log('  [2] rid:', data.vocabulary[0][2]);
                    console.log('  [3] spelling:', data.vocabulary[0][3]);
                    console.log('  [4] reading:', data.vocabulary[0][4]);
                    console.log('  [5] frequency_rank:', data.vocabulary[0][5]);
                    console.log('  [6] part_of_speech:', data.vocabulary[0][6]);
                    console.log('  [7] meanings_chunks:', data.vocabulary[0][7]);
                    console.log('  [8] meanings_part_of_speech:', data.vocabulary[0][8]);
                    console.log('  [9] card_state:', data.vocabulary[0][9]);
                    console.log('  [10] pitch_accent:', data.vocabulary[0][10]);
                }
                lastApiResponse = data;

                // Highlight the text using jpd-breader approach
                applyHighlightingToText(originalText, data);

                // Show parsing summary - now based on processed sub-words
                const totalTokens = data.tokens ? data.tokens.length : 0;

                console.log('Parsing summary:', {
                    totalTokens,
                    vocabularyEntries: data.vocabulary ? data.vocabulary.length : 0
                });

                // Status will be shown by the highlighting function
                const statusMsg = `Parsed ${totalTokens} tokens.`;

                showStatus(statusMsg, 'success');

            } catch (error) {
                console.error('Parse error:', error);
                showStatus(`Parse failed: ${error.message}`, 'error');
            }
        }

        function highlightText(originalText, cleanedText, katakanaWords, parseData) {
            console.log('highlightText called with:', { originalText, cleanedText, katakanaWords, parseData });

            const { tokens, vocabulary } = parseData;
            const container = document.getElementById('highlightedText');

            console.log('Container before clearing:', container.innerHTML.substring(0, 100));
            container.innerHTML = '';
            console.log('Container after clearing');

            console.log('Tokens:', tokens.length, 'Vocabulary:', vocabulary.length, 'Katakana:', katakanaWords.length);

            // Always show that parsing occurred by adding a processed class
            container.classList.add('parsed-text');
            console.log('Added parsed-text class');

            const fragment = document.createDocumentFragment();
            let highlightedCount = 0;

            console.log('Reconstructing original text with katakana in place...');

            // Create position mapping from JPDB positions (in fully cleaned text) to original text positions
            const getOriginalPosition = (cleanedPos) => {
                let originalPos = 0;
                let currentCleanedPos = 0;

                while (originalPos < originalText.length && currentCleanedPos <= cleanedPos) {
                    const char = originalText[originalPos];
                    const isKatakana = katakanaWords.some(kw => originalPos >= kw.startPos && originalPos < kw.endPos);
                    const isPunct = /[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char);

                    if (!isKatakana && !isPunct) {
                        if (currentCleanedPos === cleanedPos) {
                            return originalPos;
                        }
                        currentCleanedPos++;
                    }
                    originalPos++;
                }

                return originalPos;
            };

            // Collect all elements (Japanese tokens + katakana) with their positions
            const elements = [];

            // Add Japanese tokens with mapped positions
            if (tokens && tokens.length > 0 && vocabulary && vocabulary.length > 0) {
                let cleanedPos = 0;

                tokens.forEach((tokenArray, index) => {
                    const vocabIndex = tokenArray[0];
                    const reportedLength = tokenArray[2];

                    const charCount = Math.round(reportedLength / 3);
                    const tokenText = cleanedText.substr(cleanedPos, charCount);

                    if (tokenText && vocabIndex >= 0 && vocabIndex < vocabulary.length) {
                        const vocabArray = vocabulary[vocabIndex];
                        console.log(`Raw vocab data for "${tokenText}" (index ${vocabIndex}):`, vocabArray);
                        if (Array.isArray(vocabArray) && vocabArray.length >= 6) {
                            console.log(`Extracting: vid=v[0]=${vocabArray[0]}, sid=v[1]=${vocabArray[1]}, spelling=v[${3}]=${vocabArray[3]}, reading=v[${4}]=${vocabArray[4]}, card_state=v[${9}]=${vocabArray[9]}`);

                            const originalStartPos = getOriginalPosition(cleanedPos);
                            console.log(`Mapping token "${tokenText}" from cleaned pos ${cleanedPos} to original pos ${originalStartPos}`);

                            const vocabId = `vocab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                            const vocabData = {
                                vocabId: vocabId,        // Store vocabId for tracking and updating
                                vid: vocabArray[0],       // vid from API
                                sid: vocabArray[1],       // sid from API
                                spelling: vocabArray[3] || '',
                                reading: vocabArray[4] || '',
                                meanings: vocabArray[7]?.flat() || [], // meanings_chunks (flattened)
                                card_state: vocabArray[9], // card_state
                                sourceText: originalText  // Store for sentence extraction
                            };
                            
                            // Store in registry
                            vocabDataRegistry.set(vocabId, vocabData);

                            const isParticle = ['„ÅØ', '„Åå', '„Çí', '„Å´', '„Åß', '„Å®', '„Åã', '„ÇÇ', '„Å≠', '„Çà', '„Å™', '„ÅÆ', '„Å∏', '„Åã„Çâ', '„Åæ„Åß', '„Å†„Åë', '„Åó„Åã', '„Çà„Çä', '„Åª„Å©'].includes(tokenText);

                            elements.push({
                                type: 'japanese',
                                text: tokenText,
                                vocabId: vocabId,      // Include vocabId in element
                                vocabData: vocabData,
                                isParticle: isParticle,
                                position: originalStartPos,
                                endPosition: originalStartPos + tokenText.length
                            });
                        }
                    }

                    cleanedPos += charCount;
                });
            }

            // Add katakana words
            katakanaWords.forEach(katakanaWord => {
                console.log(`Adding katakana "${katakanaWord.word}" at positions ${katakanaWord.startPos}-${katakanaWord.endPos}`);
                elements.push({
                    type: 'katakana',
                    text: katakanaWord.word,
                    position: katakanaWord.startPos,
                    endPosition: katakanaWord.endPos
                });
            });

            // Sort elements by position and reconstruct
            elements.sort((a, b) => a.position - b.position);
            console.log('Sorted elements:', elements.map(e => `${e.type}:${e.text}@${e.position}-${e.endPosition}`));

            let currentPos = 0;
            let elementIndex = 0;

            while (currentPos < originalText.length) {
                if (elementIndex < elements.length && currentPos === elements[elementIndex].position) {
                    // Add the highlighted element at this position
                    const element = elements[elementIndex];

                    if (element.type === 'japanese') {
                        const vocabData = element.vocabData;
                        const isParticle = element.isParticle;

                        const stateClass = getStateClass(vocabData.card_state);
                        let highlightClass = `vocab-highlight vocab-${stateClass}`;
                        let title = `${element.text}: ${vocabData.meanings.join('; ') || vocabData.reading || 'No definition'} [${vocabData.card_state || 'unknown'} ‚Üí ${stateClass}]`;

                        console.log(`Highlighting "${element.text}": card_state=${vocabData.card_state} (type: ${typeof vocabData.card_state}), stateClass=${stateClass}, finalClass=${highlightClass}`);

                        const span = document.createElement('span');
                        span.className = highlightClass;
                        span.textContent = element.text;
                        span.title = title;
                        span.dataset.vocabId = element.vocabId || vocabData.vocabId; // Store vocabId for later updates
                        span.onclick = () => showVocabPopup(vocabData, element.text, span);
                        span.style.cursor = 'pointer';
                        span.style.display = 'inline-block';
                        span.style.margin = '0 1px';

                        // Set background color directly based on state
                        const bgColors = {
                            'new': '#e0f2fe',           // Sky blue
                            'learning': '#fed7aa',
                            'known': '#d9f99d',
                            'not-in-deck': '#fce7f3',   // Light pink
                            'locked': '#f3e8ff',
                            'redundant': '#fef3c7',
                            'failed': '#fecaca',
                            'suspended': '#f1f5f9',
                            'blacklisted': '#f9fafb',
                            'due': '#d1fae5',           // Light green
                            'never-forget': '#d9f99d'
                        };

                        if (isParticle) {
                            highlightClass = 'vocab-particle';
                            title = `Particle ${element.text}: ${vocabData.meanings.join('; ') || 'Grammar particle'}`;
                            // Override with particle colors
                            span.style.backgroundColor = '#f3f4f6';
                            span.style.color = '#6b7280';
                            span.style.border = '1px solid #d1d5db';
                        } else if (bgColors[stateClass]) {
                            span.style.backgroundColor = bgColors[stateClass];
                            span.style.border = '1px solid rgba(0,0,0,0.1)';
                            span.style.borderRadius = '2px';
                            span.style.padding = '1px 2px';
                        }

                        console.log(`Created span for "${element.text}" with state "${stateClass}" and inline background "${span.style.backgroundColor}"`);

                        fragment.appendChild(span);
                        highlightedCount++;
                        console.log(`Added Japanese highlight: "${element.text}" at pos ${currentPos}`);
                    } else if (element.type === 'katakana') {
                    const span = document.createElement('span');
                    span.className = 'vocab-katakana';
                    span.textContent = element.text;
                    span.title = `Katakana: ${element.text} (foreign word)`;
                    span.style.cursor = 'pointer';
                    span.style.display = 'inline-block';
                    span.style.margin = '0 1px';
                    span.style.backgroundColor = '#e0f2fe';
                    span.style.border = '1px solid #0ea5e9';
                    span.style.color = '#0c4a6e';
                    span.style.borderRadius = '2px';
                    span.style.padding = '1px 2px';

                        fragment.appendChild(span);
                        highlightedCount++;
                        console.log(`Added katakana highlight: "${element.text}" at pos ${currentPos}`);
                    }

                    currentPos = element.endPosition;
                    elementIndex++;
                } else {
                    // Find the next non-highlighted character
                    let nextElementPos = originalText.length;
                    if (elementIndex < elements.length) {
                        nextElementPos = elements[elementIndex].position;
                    }

                    // Add plain text until the next element
                    if (currentPos < nextElementPos) {
                        const plainText = originalText.slice(currentPos, nextElementPos);
                        if (plainText) {
                            fragment.appendChild(document.createTextNode(plainText));
                            console.log(`Added plain text: "${plainText}" from ${currentPos} to ${nextElementPos}`);
                        }
                        currentPos = nextElementPos;
                    } else {
                        // No more plain text, move to next element
                        if (elementIndex < elements.length) {
                            currentPos = elements[elementIndex].endPosition;
                            elementIndex++;
                        } else {
                            break;
                        }
                    }
                }
            }

            console.log('Fragment created with', fragment.childNodes.length, 'child nodes');
            console.log('Highlighted count:', highlightedCount);

            if (fragment.childNodes.length > 0) {
                container.appendChild(fragment);
                console.log('Fragment appended to container');
            } else {
                console.log('Fragment is empty, using fallback');
                // Fallback: just show the original text
                const fallbackText = document.createTextNode(originalText);
                container.appendChild(fallbackText);
            }

            // Add a visual indicator that parsing occurred
            const indicator = document.createElement('div');
            indicator.className = 'text-xs text-gray-500 mt-2 pt-2 border-t border-gray-200';
            const totalSubWords = highlightedCount; // This is actually sub-words, not tokens
            indicator.innerHTML = `
                <span class="inline-block w-2 h-2 bg-green-500 rounded-full mr-2"></span>
                Text parsed ‚Ä¢ ${highlightedCount} words highlighted ‚Ä¢ ${tokens ? tokens.length : 0} original tokens
            `;
            container.appendChild(indicator);

            console.log('Final container HTML length:', container.innerHTML.length);
            console.log('Final container first 200 chars:', container.innerHTML.substring(0, 200) + '...');
        }

        function getStateClass(state) {
            if (!state) return 'not-in-deck';

            // Handle array states (some card_state values are arrays)
            if (Array.isArray(state)) {
                state = state.join(',');
            }

            // Handle numeric states (legacy)
            if (typeof state === 'number') {
                if (state <= 4) return 'learning';
                return 'known';
            }

            // Convert to string and split by comma to handle complex states
            const stateStr = String(state).toLowerCase();
            const states = stateStr.split(',').map(s => s.trim());

            // Priority matching (most specific to general)
            if (states.includes('never-forget')) return 'never-forget';
            if (states.includes('failed')) return 'failed';
            if (states.includes('due')) return 'due';
            if (states.includes('suspended')) return 'suspended';
            if (states.includes('blacklisted')) return 'blacklisted';
            if (states.includes('locked')) return 'locked';
            if (states.includes('redundant')) return 'redundant';
            if (states.includes('known')) return 'known';
            if (states.includes('learning')) return 'learning';
            if (states.includes('new')) return 'new';

            // If we have states but none match, check if it's in a deck
            if (states.length > 0 && !states.includes('not-in-deck')) {
                return 'learning'; // Default for known words
            }

            // Not in deck or unknown state
            return 'not-in-deck';
        }

        function showVocabPopup(vocabData, word, element) {
            console.log('üìù showVocabPopup called with:', { vocabData, word, hasVid: !!vocabData.vid, hasSid: !!vocabData.sid });
            
            // Remove existing popup
            const existing = document.querySelector('.vocab-popup');
            if (existing) existing.remove();

            const popup = document.createElement('div');
            popup.className = 'vocab-popup fixed bg-white border rounded-lg shadow-lg p-4 max-w-sm z-50';
            popup.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">${word}</h3>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-gray-500 hover:text-gray-700">√ó</button>
                </div>
                ${vocabData.baseForm ? `<p class="text-sm text-blue-600 mb-1">Base form: ${vocabData.baseForm}</p>` : ''}
                ${vocabData.reading && vocabData.reading !== word && vocabData.reading !== vocabData.baseForm ? `<p class="text-sm text-gray-600 mb-2">Reading: ${vocabData.reading}</p>` : ''}
                <div class="text-sm mb-3 max-h-32 overflow-y-auto">${Array.isArray(vocabData.meanings) ? vocabData.meanings.join('; ') : vocabData.meanings || 'No definition available'}</div>
                <div class="flex gap-2">
                    <button onclick="addToDeck('${vocabData.vocabId || vocabData.sid || 'none'}', '${word}', ${vocabData.vid !== undefined && vocabData.vid !== null ? vocabData.vid : 'null'}, ${vocabData.sid !== undefined && vocabData.sid !== null ? vocabData.sid : 'null'})" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600" ${!vocabData.vid || !vocabData.sid ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                        Add to Deck ${selectedDeckName ? '(' + selectedDeckName + ')' : ''}
                    </button>
                    <button onclick="window.open('https://jpdb.io/search?q=${encodeURIComponent(word)}', '_blank')" class="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
                        View in JPDB
                    </button>
                </div>
            `;

            document.body.appendChild(popup);

            // Position popup near the element (after it's in the DOM)
            const rect = element.getBoundingClientRect();
            const popupRect = popup.getBoundingClientRect();

            let top = rect.bottom + 5;
            let left = rect.left;

            // Adjust if popup would go off-screen
            if (left + popupRect.width > window.innerWidth) {
                left = window.innerWidth - popupRect.width - 10;
            }
            if (top + popupRect.height > window.innerHeight) {
                top = rect.top - popupRect.height - 5;
            }

            popup.style.top = top + 'px';
            popup.style.left = left + 'px';
            popup.style.position = 'fixed';
            popup.style.zIndex = '10000';

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                });
            }, 100);
        }

        // Load user's decks from JPDB
        async function loadUserDecks() {
            if (!apiKey) {
                showStatus('Please enter and save your JPDB API key first', 'error');
                return;
            }

            const deckStatus = document.getElementById('deckStatus');
            const deckDropdown = document.getElementById('deckDropdown');
            deckStatus.textContent = 'Loading decks...';

            try {
                const response = await fetch('https://jpdb.io/api/v1/list-user-decks', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        fields: ['id', 'name'] // Only need id and name
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to load decks: ${response.status}`);
                }

                const data = await response.json();
                userDecks = data.decks || [];

                deckStatus.textContent = `Loaded ${userDecks.length} decks`;
                showStatus(`Loaded ${userDecks.length} decks from JPDB`, 'success');

                // Populate dropdown
                deckDropdown.innerHTML = '<option value="">Select a deck...</option>';
                userDecks.forEach((deck, index) => {
                    const option = document.createElement('option');
                    option.value = deck[0]; // id
                    option.textContent = deck[1]; // name
                    if (deck[0] === selectedDeckId) {
                        option.selected = true;
                    }
                    deckDropdown.appendChild(option);
                });
                
                // Enable dropdown
                deckDropdown.disabled = false;

                // Update deck display
                updateDeckDisplay();

            } catch (error) {
                console.error('Error loading decks:', error);
                deckStatus.textContent = 'Error loading decks';
                showStatus('Error loading decks: ' + error.message, 'error');
            }
        }

        // Select deck from dropdown
        function selectDeckFromDropdown(deckId) {
            if (!deckId) {
                selectedDeckId = null;
                selectedDeckName = null;
                updateDeckDisplay();
                return;
            }

            const deck = userDecks.find(d => d[0] === deckId);
            if (!deck) return;

            selectedDeckId = deck[0];
            selectedDeckName = deck[1];

            // Save to localStorage
            localStorage.setItem('selected-jpdb-deck-id', selectedDeckId);
            localStorage.setItem('selected-jpdb-deck-name', selectedDeckName);

            // Update display
            updateDeckDisplay();
            showStatus(`Selected deck: ${selectedDeckName}`, 'success');
        }

        // Select a deck from the loaded list
        function selectDeck() {
            if (userDecks.length === 0) {
                showStatus('Please load your decks first', 'info');
                return;
            }

            // Create deck selection list
            const deckList = userDecks.map((deck, index) => `${index + 1}. ${deck[1]}`).join('\n');
            const input = prompt(`Select a deck (1-${userDecks.length}):\n\n${deckList}`);

            if (!input) return;

            const selection = parseInt(input) - 1;
            if (selection >= 0 && selection < userDecks.length) {
                selectedDeckId = userDecks[selection][0]; // id
                selectedDeckName = userDecks[selection][1]; // name

                // Save to localStorage
                localStorage.setItem('selected-jpdb-deck-id', selectedDeckId);
                localStorage.setItem('selected-jpdb-deck-name', selectedDeckName);

                // Update display
                updateDeckDisplay();
                showStatus(`Selected deck: ${selectedDeckName}`, 'success');
            } else {
                showStatus('Invalid selection', 'error');
            }
        }

        // Update the deck display
        function updateDeckDisplay() {
            const selectedDeckDiv = document.getElementById('selectedDeck');
            if (selectedDeckId && selectedDeckName) {
                selectedDeckDiv.textContent = `‚úì Selected: ${selectedDeckName}`;
                selectedDeckDiv.className = 'mt-3 px-4 py-3 bg-gradient-to-r from-green-50 to-emerald-50 rounded-xl border-2 border-green-400 text-base font-semibold shadow-md text-green-700';
            } else {
                selectedDeckDiv.textContent = 'No deck selected';
                selectedDeckDiv.className = 'mt-3 px-4 py-3 bg-white rounded-xl border-2 border-blue-400 text-base font-semibold shadow-md';
            }
        }

        // Add vocabulary to deck (updated with full implementation)
        async function addToDeck(vocabId, word, vid, sid) {
            if (!selectedDeckId) {
                showStatus('Please select a deck first', 'error');
                return;
            }

            if (!apiKey) {
                showStatus('Please enter and save your JPDB API key first', 'error');
                return;
            }

            // Validate that vid and sid are valid integers
            if (vid === null || sid === null || vid === undefined || sid === undefined) {
                console.error('Missing vocabulary IDs:', { vid, sid, word });
                showStatus('Error: Vocabulary ID information is missing. Try reloading the page.', 'error');
                return;
            }

            // Get vocabData from registry
            const vocabData = vocabDataRegistry.get(vocabId);
            
            console.log('üìã vocabData retrieved:', {
                hasVocabData: !!vocabData,
                hasSourceText: !!(vocabData && vocabData.sourceText),
                sourceTextPreview: vocabData?.sourceText?.substring(0, 80),
                word,
                spelling: vocabData?.spelling
            });

            // Get the surrounding sentence context
            const surroundingSentence = getSurroundingSentence(word, vocabData);
            
            console.log('Sentence context:', { 
                word, 
                sentence: surroundingSentence,
                length: surroundingSentence?.length,
                isJustWord: surroundingSentence === word
            });

            try {
                console.log('Adding vocabulary to deck:', { 
                    deckId: selectedDeckId, 
                    word, 
                    vid, 
                    sid,
                    vocabulary: [[vid, sid]]
                });

                // Add vocabulary to deck
                // According to JPDB API: vocabulary must be array of 2-element arrays [vid, sid]
                const addResponse = await fetch(`https://jpdb.io/api/v1/deck/${selectedDeckId}/vocabulary`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: parseInt(selectedDeckId), // Convert to integer
                        vocabulary: [[parseInt(vid), parseInt(sid)]], // vid and sid as integers in 2-element array
                        occurences: [1], // Always 1 as user specified
                        ignore_unknown: true // Don't fail if IDs are invalid
                    })
                });

                const responseData = await addResponse.json();
                console.log('Add vocabulary response:', responseData);

                if (!addResponse.ok) {
                    throw new Error(`Failed to add to deck: ${addResponse.status} - ${JSON.stringify(responseData)}`);
                }

                // Set the sentence context
                if (surroundingSentence) {
                    console.log('Setting sentence for vocabulary:', {
                        vid: parseInt(vid),
                        sid: parseInt(sid),
                        sentence: surroundingSentence.substring(0, 50) + '...'
                    });

                    const sentenceResponse = await fetch('https://jpdb.io/api/v1/set-card-sentence', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            vid: parseInt(vid), // Convert to integer
                            sid: parseInt(sid), // Convert to integer
                            sentence: surroundingSentence
                        })
                    });

                    const sentenceData = await sentenceResponse.json();
                    console.log('Set sentence response:', sentenceData);

                    if (!sentenceResponse.ok) {
                        console.warn('Failed to set sentence, but vocabulary was added:', sentenceResponse.status, sentenceData);
                    } else {
                        console.log('‚úÖ Sentence context set successfully');
                    }
                }

                // Update the cache to reflect the new card state
                if (vocabData) {
                    vocabData.card_state = 'new';
                    vocabDataRegistry.set(vocabId, vocabData);
                    console.log('‚úÖ Updated cache: card_state changed to "new"');
                    
                    // Update the visual display
                    updateVocabularyHighlight(vocabId, 'new');
                }

                // Show multiple forms of feedback
                showToast(`‚úÖ Added "${word}" to ${selectedDeckName}!`, 'success');
                showStatus(`"${word}" added to "${selectedDeckName}"! ${surroundingSentence ? 'With sentence context.' : ''}`, 'success');
                
                // Flash animation on the added word
                const addedWordSpans = document.querySelectorAll(`span[data-vocab-id="${vocabId}"]`);
                addedWordSpans.forEach(span => {
                    span.style.transition = 'transform 0.3s ease, box-shadow 0.3s ease';
                    span.style.transform = 'scale(1.2)';
                    span.style.boxShadow = '0 0 10px rgba(59, 130, 246, 0.5)';
                    setTimeout(() => {
                        span.style.transform = 'scale(1)';
                        span.style.boxShadow = 'none';
                    }, 300);
                });
            } catch (error) {
                console.error('Error adding to deck:', error);
                showStatus('Error adding to deck: ' + error.message, 'error');
            }
        }

        // Update the visual highlight for a vocabulary word when its state changes
        function updateVocabularyHighlight(vocabId, newState) {
            const vocabData = vocabDataRegistry.get(vocabId);
            if (!vocabData) return;
            
            // Find all spans with this vocabId and update their classes
            const spans = document.querySelectorAll(`span[data-vocab-id="${vocabId}"]`);
            console.log(`üé® Updating ${spans.length} spans for vocabId ${vocabId} to state "${newState}"`);
            
            spans.forEach(span => {
                // Remove old state classes
                span.classList.remove('vocab-new', 'vocab-learning', 'vocab-known', 'vocab-not-in-deck', 
                                      'vocab-due', 'vocab-failed', 'vocab-suspended', 'vocab-locked', 
                                      'vocab-redundant', 'vocab-blacklisted');
                
                // Add new state class
                span.classList.add(`vocab-${newState}`);
                
                // Update the title tooltip to reflect new state
                const oldTitle = span.title;
                const newTitle = oldTitle.replace(/\[.*?\]/, `[${newState}]`);
                span.title = newTitle;
                
                console.log(`‚úÖ Updated span class from existing state to "vocab-${newState}"`);
            });
        }

        // Extract sentence containing a word from text, with length limits
        function extractSentenceWithWord(fullText, word, maxLength = 150, vocabData = null) {
            if (!fullText || !word) return word;
            
            console.log('üîç extractSentenceWithWord:', { 
                word, 
                wordLength: word.length,
                fullTextLength: fullText.length,
                fullTextPreview: fullText.substring(0, 100),
                hasVocabData: !!vocabData,
                spelling: vocabData?.spelling
            });
            
            // Japanese sentence endings
            const sentenceEndings = /[„ÄÇÔºÅÔºü]/;
            
            // Try to find the word - try multiple variations
            let wordIndex = fullText.indexOf(word);
            
            // If not found and we have vocabData, try the spelling
            if (wordIndex === -1 && vocabData && vocabData.spelling) {
                console.log('üîç Word not found, trying spelling:', vocabData.spelling);
                wordIndex = fullText.indexOf(vocabData.spelling);
                if (wordIndex !== -1) {
                    word = vocabData.spelling; // Use spelling for extraction
                }
            }
            
            // If still not found, try finding any part of the word
            if (wordIndex === -1 && word.length > 1) {
                console.log('üîç Still not found, trying substring search');
                // Try first 2-3 characters of the word
                const searchTerm = word.substring(0, Math.min(3, word.length));
                wordIndex = fullText.indexOf(searchTerm);
                console.log('üîç Substring search result:', { searchTerm, wordIndex });
            }
            
            if (wordIndex === -1) {
                console.warn('‚ùå Word not found in text:', { word, fullTextPreview: fullText.substring(0, 100) });
                return word;
            }
            
            console.log('‚úÖ Word found at index:', wordIndex);
            
            // Split into sentences
            const sentences = fullText.split(sentenceEndings);
            
            // Find which sentence contains the word
            let currentPos = 0;
            for (let i = 0; i < sentences.length; i++) {
                const sentence = sentences[i];
                const sentenceEnd = currentPos + sentence.length;
                
                if (wordIndex >= currentPos && wordIndex < sentenceEnd) {
                    // Found the sentence containing the word
                    let result = sentence.trim();
                    
                    // Add the punctuation back if it exists
                    const nextChar = fullText[sentenceEnd];
                    if (nextChar && sentenceEndings.test(nextChar)) {
                        result += nextChar;
                    }
                    
                    console.log('‚úÖ Extracted sentence:', { result, length: result.length });
                    
                    // Truncate if too long (keep text around the word)
                    if (result.length > maxLength) {
                        const wordPosInSentence = wordIndex - currentPos;
                        const halfMax = Math.floor(maxLength / 2);
                        
                        // Try to keep the word centered
                        let start = Math.max(0, wordPosInSentence - halfMax);
                        let end = Math.min(result.length, start + maxLength);
                        
                        // Adjust if we're at the end
                        if (end === result.length && result.length > maxLength) {
                            start = Math.max(0, end - maxLength);
                        }
                        
                        result = result.substring(start, end).trim();
                        
                        // Add ellipsis if truncated
                        if (start > 0) result = '‚Ä¶' + result;
                        if (end < sentence.length) result = result + '‚Ä¶';
                        
                        console.log('‚úÇÔ∏è Truncated sentence:', { result, length: result.length });
                    }
                    
                    return result;
                }
                
                // +1 for the sentence ending character
                currentPos = sentenceEnd + 1;
            }
            
            // Fallback: if no sentence boundary found, return substring around word
            console.log('‚ö†Ô∏è No sentence boundary found, using substring');
            const start = Math.max(0, wordIndex - 75);
            const end = Math.min(fullText.length, wordIndex + 75);
            let result = fullText.substring(start, end).trim();
            
            if (start > 0) result = '‚Ä¶' + result;
            if (end < fullText.length) result = result + '‚Ä¶';
            
            return result;
        }

        // Get surrounding sentence context for vocabulary
        function getSurroundingSentence(word, vocabData) {
            // Use vocabData if provided and has source text
            if (vocabData && vocabData.sourceText) {
                return extractSentenceWithWord(vocabData.sourceText, word, 150, vocabData);
            }
            
            // Fallback: try DOM traversal (existing logic)
            const highlightedSpans = document.querySelectorAll('.vocab-highlight');
            
            for (const span of highlightedSpans) {
                if (span.textContent.includes(word)) {
                    let parent = span.parentElement;
                    
                    while (parent) {
                        if (parent.textContent && parent.textContent.length > 50 && parent.textContent.length < 500) {
                            return extractSentenceWithWord(parent.textContent, word, 150, vocabData);
                        }
                        parent = parent.parentElement;
                    }
                }
            }
            
            return word; // Ultimate fallback
        }

        // Load saved deck selection on page load
        function loadSavedDeckSelection() {
            if (selectedDeckId && selectedDeckName) {
                updateDeckDisplay();
                
                // Update dropdown selection if available
                const deckDropdown = document.getElementById('deckDropdown');
                if (deckDropdown && !deckDropdown.disabled) {
                    deckDropdown.value = selectedDeckId;
                }
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('connectionStatus');
            const colors = {
                success: 'text-green-600 bg-green-50 border-green-200',
                error: 'text-red-600 bg-red-50 border-red-200',
                info: 'text-blue-600 bg-blue-50 border-blue-200'
            };

            statusDiv.innerHTML = `
                <div class="p-3 rounded-md border ${colors[type] || colors.info}">
                    ${message}
                </div>
            `;

            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 5000);
        }

        function simpleJapaneseTokenization(text) {
            // Basic Japanese word tokenization for demo purposes
            // This is a simplified approach - a full tokenizer would be more complex

            const words = [];
            let currentWord = '';

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1] || '';

                // Particles that typically end words/phrases
                const particles = ['„ÅØ', '„Åå', '„Çí', '„Å´', '„Åß', '„Å®', '„Åã', '„ÇÇ', '„Å≠', '„Çà', '„Å™', '„ÅÆ', '„Å∏', '„Åã„Çâ', '„Åæ„Åß', '„Å†„Åë', '„Åó„Åã', '„Çà„Çä', '„Åª„Å©'];

                // Grammar endings
                const endings = ['„Å™„ÅÑ', '„Åæ„Åô', '„Åü', '„Å¶', '„Åß', '„Åü„ÅÑ', '„Å¶„Çã'];

                if (particles.includes(char)) {
                    // Particle - save current word and start new one with particle
                    if (currentWord) {
                        words.push(currentWord);
                        currentWord = '';
                    }
                    words.push(char);
                } else if (endings.some(ending => text.substr(i, ending.length) === ending)) {
                    // Grammar ending - include it with current word
                    const ending = endings.find(e => text.substr(i, e.length) === e);
                    currentWord += ending;
                    words.push(currentWord);
                    currentWord = '';
                    i += ending.length - 1; // Skip the characters we just processed
                } else {
                    // Regular character - add to current word
                    currentWord += char;
                }
            }

            // Add any remaining word
            if (currentWord) {
                words.push(currentWord);
            }

            return words.filter(word => word.length > 0);
        }

        function splitTokenAtWordBoundaries(tokenText, basePosition) {
            // Simple Japanese word boundary detection
            // This is a heuristic approach to split JPDB morphological tokens

            const subWords = [];
            let currentPos = 0;

            // Common particles that often indicate word boundaries
            const particles = ['„ÅØ', '„Åå', '„Çí', '„Å´', '„Åß', '„Å®', '„Åã', '„ÇÇ', '„Å≠', '„Çà', '„Å™', '„ÅÆ', '„Å¶', '„Åü', '„Å†', '„Åã„Çâ', '„Åæ„Åß', '„Å†„Åë', '„Åó„Åã', '„Çà„Çä', '„Åª„Å©'];

            // Grammar endings that might indicate separate words
            const grammarEndings = ['„Å™„ÅÑ', '„Åæ„Åô', '„Åü', '„Å¶', '„Åß', '„Åü„Çâ', '„Çå„Çã', '„Çâ„Çå„Çã', '„Åõ„Çã', '„Åï„Åõ„Çã', '„Åü„ÅÑ', '„Åü„Åè', '„Åô„Åé„Çã', '„Åô„Åé', '„Åù„ÅÜ', '„Åø„Åü„ÅÑ'];

            let remainingText = tokenText;

            while (remainingText.length > 0) {
                let foundBoundary = false;

                // Check for particle boundaries (work backwards from end)
                for (const particle of particles) {
                    if (remainingText.endsWith(particle)) {
                        const beforeParticle = remainingText.slice(0, -particle.length);
                        if (beforeParticle.length > 0) {
                            // Add the word before the particle
                            subWords.push({
                                text: beforeParticle,
                                relativePosition: currentPos
                            });
                            currentPos += beforeParticle.length;
                        }

                        // Add the particle
                        subWords.push({
                            text: particle,
                            relativePosition: currentPos
                        });
                        currentPos += particle.length;

                        remainingText = '';
                        foundBoundary = true;
                        break;
                    }
                }

                if (!foundBoundary) {
                    // Check for grammar ending boundaries
                    for (const ending of grammarEndings) {
                        if (remainingText.endsWith(ending)) {
                            const beforeEnding = remainingText.slice(0, -ending.length);
                            if (beforeEnding.length > 0) {
                                // Add the word before the ending
                                subWords.push({
                                    text: beforeEnding,
                                    relativePosition: currentPos
                                });
                                currentPos += beforeEnding.length;
                            }

                            // Add the ending
                            subWords.push({
                                text: ending,
                                relativePosition: currentPos
                            });
                            currentPos += ending.length;

                            remainingText = '';
                            foundBoundary = true;
                            break;
                        }
                    }
                }

                if (!foundBoundary) {
                    // No boundary found, add the entire remaining text as one word
                    subWords.push({
                        text: remainingText,
                        relativePosition: currentPos
                    });
                    break;
                }
            }

            return subWords;
        }

        function extractKatakanaWords(text) {
            // JPDB doesn't parse katakana words, so we need to extract them separately
            // Find sequences of katakana characters (including nakaguro „Éª)
            const katakanaRegex = /[\u30A0-\u30FF„Éª]+/g;
            const katakanaWords = [];

            // Extract katakana words with their positions in the original text
            let match;
            while ((match = katakanaRegex.exec(text)) !== null) {
                const word = match[0];
                const startPos = match.index;
                const endPos = startPos + word.length;

                katakanaWords.push({
                    word: word,
                    startPos: startPos,
                    endPos: endPos
                });
            }

            // Remove katakana to get text for JPDB parsing
            let cleanedText = text.replace(/[\u30A0-\u30FF„Éª]+/g, '');

            return { cleanedText, katakanaWords };
        }

        function cleanTextForJPDB(text) {
            // Remove punctuation that JPDB eliminates, but keep katakana in the text
            // JPDB will naturally skip katakana words it doesn't recognize
            return text
                .replace(/[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}]/g, '') // Brackets and parentheses
                .replace(/[„ÄÅ„ÄÇ,.Ôºé]/g, '') // Sentence-ending punctuation
                .replace(/[!?ÔºÅÔºü]/g, '') // Question/exclamation marks
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
        }

        function createOriginalPositionMap(originalText, cleanedText, katakanaWords) {
            // Create a mapping system between cleaned and original text positions
            // This accounts for removed katakana and punctuation

            const map = {
                cleanedToOriginal: function(cleanedPos) {
                    let originalPos = 0;
                    let currentCleanedPos = 0;

                    // Skip over katakana positions in original text
                    for (let i = 0; i < originalText.length && currentCleanedPos <= cleanedPos; i++) {
                        const char = originalText[i];
                        const isInKatakana = katakanaWords.some(kw => i >= kw.startPos && i < kw.endPos);

                        if (!isInKatakana && !/[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char)) {
                            if (currentCleanedPos === cleanedPos) {
                                return originalPos;
                            }
                            currentCleanedPos++;
                        }
                        originalPos++;
                    }

                    return originalPos;
                },

                originalToCleaned: function(originalPos) {
                    let cleanedPos = 0;

                    for (let i = 0; i < originalPos && i < originalText.length; i++) {
                        const char = originalText[i];
                        const isInKatakana = katakanaWords.some(kw => i >= kw.startPos && i < kw.endPos);

                        if (!isInKatakana && !/[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char)) {
                            cleanedPos++;
                        }
                    }

                    return cleanedPos;
                }
            };

            return map;
        }

        function addPunctuationFromOriginal(originalText, cleanedText, fragment, positionMap) {
            // Add punctuation from original text that's not in cleaned text
            // This ensures punctuation appears in the final highlighted output
            let lastOriginalPos = 0;
            let fragmentIndex = 0;

            for (let origPos = 0; origPos < originalText.length; origPos++) {
                const char = originalText[origPos];
                const isPunctuation = /[„Äå„Äç„Äé„Äè„Ää„Äã„Äà„Äâ„Ää„Äã„Äê„Äë„Ää„Äã()ÔºàÔºâ[\]{}„Äê„Äë„Ää„Äã„ÄÅ„ÄÇ,.Ôºé,„Éª:;!ÔºÅÔºü\s]/.test(char);

                if (isPunctuation) {
                    // Find where to insert this punctuation in the fragment
                    // For now, just add it at the end (this is a simplified approach)
                    const punctNode = document.createTextNode(char);
                    fragment.appendChild(punctNode);
                }
            }
        }

        function loadSampleText() {
            // Using text with punctuation and katakana
            const sampleText = `„ÄåÂΩº„Å´„Å®„Å£„Å¶‰∏çÈÅã„Å†„Å£„Åü„ÅÆ„ÅØ„ÄÅ„Éï„Ç©„É≥„Éª„Éá„Ç¢„Éª„Éò„É´„ÉÑ„ÅåËá™ÂàÜ„ÇíÁΩ†„Å´„Åã„Åë„ÇãË®àÁîª„Çí„ÄÅË≠¶ÈÉ®„Å®„Åª„Å®„Çì„Å©ÂêåÊôÇ„Å´Áü•„Å£„Åü„Åì„Å®„Åß„Åó„Åü„ÄÇ`;
            document.getElementById('japaneseText').value = sampleText;
        }

        function showRawResponse() {
            if (!lastApiResponse) {
                showStatus('No API response available. Parse some text first.', 'info');
                return;
            }

            const responseText = JSON.stringify(lastApiResponse, null, 2);
            const highlightedContainer = document.getElementById('highlightedText');

            // Clear current content and show raw response
            highlightedContainer.innerHTML = `
                <h3 class="font-bold text-lg mb-3">Raw API Response:</h3>
                <pre class="bg-gray-800 text-green-400 p-4 rounded text-xs overflow-auto max-h-96">${responseText}</pre>
                <button onclick="parseAndHighlight()" class="mt-3 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">
                    Back to Highlighted View
                </button>
            `;

            showStatus('Showing raw API response. Click button to return to highlighted view.', 'info');
        }

        // EPUB Reader Functions
        async function loadEPUB(file) {
            try {
                console.log('Starting EPUB load for file:', file.name, 'size:', file.size, 'type:', file.type);
                updateReadingProgress('Loading EPUB file...');

                // Validate file
                if (!file) {
                    throw new Error('No file selected');
                }

                if (!file.name.toLowerCase().endsWith('.epub')) {
                    throw new Error('File must be an EPUB (.epub)');
                }

                console.log('Checking if JSZip is loaded...');
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip library not loaded. Check your internet connection and try refreshing the page.');
                }

                currentEpubFile = file;
                currentBookId = file.name;

                console.log('Loading EPUB as ZIP file...');

                // Load the EPUB file as a ZIP archive
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);

                console.log('EPUB ZIP loaded, files:', Object.keys(zip.files).length);

                // Extract text content from HTML files
                const textContent = await extractTextFromEPUB(zip);
                console.log('Extracted text content, length:', textContent.length);

                if (textContent.length === 0) {
                    throw new Error('No readable text content found in EPUB');
                }

                // Store the extracted content
                currentEpub = {
                    content: textContent,
                    chapters: splitIntoChapters(textContent),
                    metadata: extractMetadata(zip)
                };

                console.log('EPUB processed successfully');
                console.log('Chapters found:', currentEpub.chapters.length);
                console.log('Metadata:', currentEpub.metadata);

                updateReadingProgress('EPUB loaded successfully');

                // Enable navigation buttons
                document.getElementById('prevChapterBtn').disabled = false;
                document.getElementById('nextChapterBtn').disabled = false;

                // Load saved progress or first chapter
                const savedProgress = loadReadingProgress(currentBookId);
                const startChapter = savedProgress ? savedProgress.chapterIndex : 0;

                console.log('Loading chapter:', startChapter);
                updateReadingProgress(`Loading chapter ${startChapter + 1}...`);
                loadChapter(startChapter);

            } catch (error) {
                console.error('Error loading EPUB:', error);
                console.error('Error details:', error.stack);
                updateReadingProgress('Error loading EPUB file');
                showStatus(`EPUB Error: ${error.message}`, 'error');

                // Reset state on error
                currentEpub = null;
                currentChapter = null;
                currentEpubFile = null;
                currentBookId = null;
            }
        }

        async function loadChapter(chapterIndex) {
            try {
                if (!currentEpub) return;

                const chapters = currentEpub.chapters;
                if (chapterIndex < 0 || chapterIndex >= chapters.length) {
                    return;
                }

                currentChapter = chapterIndex;
                currentPage = 0;

                // Split chapter into pages
                const chapterContent = chapters[chapterIndex];
                chapterPages = splitIntoPages(chapterContent);
                totalPages = chapterPages.length;

                console.log(`Chapter ${chapterIndex + 1} split into ${totalPages} pages`);

                // Enable/disable page navigation buttons
                updatePageNavigationButtons();

                // Display first page
                displayPage(currentPage);

                updateReadingProgress(`Chapter ${chapterIndex + 1} of ${chapters.length} - Page ${currentPage + 1} of ${totalPages}`);

                // Parse text for JPDB highlighting (only current page for performance)
                const currentPageContent = chapterPages[currentPage];
                parseChapterText(currentPageContent);

            } catch (error) {
                console.error('Error loading chapter:', error);
                updateReadingProgress('Error loading chapter');
            }
        }

        function splitIntoPages(text) {
            const pages = [];
            const paragraphs = text.split('\n').filter(p => p.trim());

            let currentPage = '';
            const maxPageLength = 1500; // Characters per page

            for (const paragraph of paragraphs) {
                if ((currentPage + paragraph).length <= maxPageLength) {
                    currentPage += (currentPage ? '\n' : '') + paragraph;
                } else {
                    if (currentPage) {
                        pages.push(currentPage);
                        currentPage = '';
                    }

                    // If paragraph itself is too long, split it
                    if (paragraph.length <= maxPageLength) {
                        currentPage = paragraph;
                    } else {
                        // Split long paragraph into multiple pages
                        const words = paragraph.split(' ');
                        let tempPage = '';

                        for (const word of words) {
                            if ((tempPage + word).length <= maxPageLength) {
                                tempPage += (tempPage ? ' ' : '') + word;
                            } else {
                                if (tempPage) {
                                    pages.push(tempPage);
                                }
                                tempPage = word;
                            }
                        }

                        if (tempPage) {
                            currentPage = tempPage;
                        }
                    }
                }
            }

            if (currentPage) {
                pages.push(currentPage);
            }

            return pages;
        }

        function displayPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= chapterPages.length) return;

            const pageContent = chapterPages[pageIndex];

            // Format the page content with basic HTML structure
            const formattedContent = pageContent
                .split('\n')
                .map(paragraph => paragraph.trim())
                .filter(paragraph => paragraph.length > 0)
                .map(paragraph => `<p style="margin-bottom: 1em; line-height: 1.6;">${paragraph}</p>`)
                .join('');

            const readerDiv = document.getElementById('epubReader');

            readerDiv.innerHTML = `
                <div style="padding: 20px; font-family: 'Noto Sans JP', sans-serif; max-width: 800px; margin: 0 auto;">
                    <div style="text-align: justify;">${formattedContent}</div>
                </div>
            `;

            updatePageIndicator();
        }

        function updatePageIndicator() {
            const indicator = document.getElementById('pageIndicator');
            if (chapterPages.length > 0) {
                indicator.textContent = `${currentPage + 1} / ${totalPages}`;
            } else {
                indicator.textContent = 'Ready';
            }
        }

        function updatePageNavigationButtons() {
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');

            prevPageBtn.disabled = currentPage <= 0;
            nextPageBtn.disabled = currentPage >= totalPages - 1;
        }

        async function parseChapterText(chapterText) {
            try {
                // Clean and prepare text for parsing
                chapterText = chapterText.replace(/\s+/g, ' ').trim();

                if (chapterText.length > 0) {
                    console.log('Parsing chapter text (length:', chapterText.length, '):', chapterText.substring(0, 200) + '...');

                    const parseData = await parseTextForHighlightingChunked(chapterText);
                    console.log('Vocabulary returned from JPDB:', parseData.vocabulary?.map(v => v[2]) || []);
                    console.log('Number of chunks processed:', parseData.tokens?.length || 0);

                    // Apply highlighting to the rendered content
                    applyHighlightingToChapter(parseData);
                }

            } catch (error) {
                console.error('Error parsing chapter text:', error);
            }
        }

        async function parseSingleChunk(rawText) {
            try {
                const response = await fetch('https://jpdb.io/api/v1/parse', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        text: rawText,
                        token_fields: ['vocabulary_index', 'position', 'length', 'furigana'],
                        vocabulary_fields: ['vid', 'sid', 'rid', 'spelling', 'reading', 'frequency_rank', 'part_of_speech', 'meanings_chunks', 'meanings_part_of_speech', 'card_state', 'pitch_accent'],
                        position_length_encoding: 'utf16'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} : ${response.statusText}`);
                }

                const data = await response.json();
                return {
                    tokens: data.tokens || [],
                    vocabulary: data.vocabulary || [],
                    rawText
                };
            } catch (error) {
                console.error('Error parsing single chunk:', error);
                throw error;
            }
        }

        // Cache management functions
        function saveJpdbCache() {
            try {
                localStorage.setItem(JPDB_CACHE_KEY, JSON.stringify(jpdbCache));
            } catch (error) {
                console.warn('Error saving JPDB cache:', error);
            }
        }

        function saveTranscriptCache() {
            try {
                localStorage.setItem(TRANSCRIPT_CACHE_KEY, JSON.stringify(transcriptCache));
            } catch (error) {
                console.warn('Error saving transcript cache:', error);
            }
        }

        function clearAllCaches() {
            try {
                localStorage.removeItem(JPDB_CACHE_KEY);
                localStorage.removeItem(TRANSCRIPT_CACHE_KEY);
                jpdbCache = {};
                transcriptCache = {};
                console.log('‚úÖ All caches cleared');
                alert('Cache cleared! Refresh the page to test fresh API calls.');
            } catch (error) {
                console.warn('Error clearing caches:', error);
            }
        }

        function showCacheInfo() {
            try {
                const jpdbCacheSize = Object.keys(jpdbCache).length;
                const transcriptCacheSize = Object.keys(transcriptCache).length;

                // Calculate approximate storage size
                const jpdbCacheData = JSON.stringify(jpdbCache);
                const transcriptCacheData = JSON.stringify(transcriptCache);
                const jpdbSizeKB = Math.round(jpdbCacheData.length / 1024);
                const transcriptSizeKB = Math.round(transcriptCacheData.length / 1024);
                const totalSizeKB = jpdbSizeKB + transcriptSizeKB;

                const message = `
üìä Cache Information:

JPDB Parse Results: ${jpdbCacheSize} entries (${jpdbSizeKB} KB)
Transcript Results: ${transcriptCacheSize} entries (${transcriptSizeKB} KB)
Total Cached Data: ${totalSizeKB} KB

Cached entries help speed up repeated parsing of the same content.
Clear cache to test fresh API calls or free up storage space.
                `.trim();

                alert(message);
            } catch (error) {
                console.warn('Error showing cache info:', error);
                alert('Unable to read cache information.');
            }
        }

        function getCacheKey(text) {
            // Create a simple hash of the text for caching
            let hash = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }

        async function parseTextForHighlightingChunked(text) {
            const cacheKey = getCacheKey(text);

            // Check cache first
            if (jpdbCache[cacheKey]) {
                console.log(`‚úÖ Using cached JPDB result for text (${text.length} chars)`);
                return jpdbCache[cacheKey];
            }
            console.log(`parseTextForHighlightingChunked called with text length: ${text.length}`);
            console.log(`Text to parse: "${text.substring(0, 150)}"`);

            // For large texts, use chunking to avoid API limits
            const maxChunkSize = 400; // Smaller chunks to avoid rate limiting
            if (text.length > maxChunkSize) {
                console.log(`Text too long (${text.length} chars), using chunked parsing...`);
                return await parseTextInChunksForTranscript(text, cacheKey);
            }

            // Send raw text directly to JPDB (like jpd-breader) - no preprocessing
            try {
                const result = await parseSingleChunk(text);
                console.log(`Parse result: ${result.vocabulary?.length || 0} vocabulary entries, ${result.tokens?.length || 0} tokens`);

                // Cache the result
                const finalResult = { ...result, rawText: text };
                jpdbCache[cacheKey] = finalResult;
                saveJpdbCache();

                return finalResult;
            } catch (error) {
                console.log('Single chunk failed:', error);
                throw error;
            }
        }

        async function parseTextInChunksForTranscript(text, cacheKey) {
            // Check cache first
            if (jpdbCache[cacheKey]) {
                console.log(`‚úÖ Using cached JPDB result for chunked text (${text.length} chars)`);
                return jpdbCache[cacheKey];
            }

            // Split into manageable chunks for transcript parsing
            const chunks = splitIntoChunks(text, 800); // Larger chunks now that double parsing is fixed
            console.log(`Split transcript into ${chunks.length} chunks for API processing`);

            const allTokens = [];
            const allVocabulary = [];
            let globalTokenOffset = 0;
            let globalVocabIndex = 0;

            // Process each chunk with rate limiting
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                console.log(`Processing transcript chunk ${i + 1}/${chunks.length}: "${chunk.substring(0, 50)}..."`);

                try {
                    const response = await fetch('https://jpdb.io/api/v1/parse', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: chunk,
                            token_fields: ['vocabulary_index', 'position', 'length'],
                            vocabulary_fields: ['vid', 'sid', 'rid', 'spelling', 'reading', 'frequency_rank', 'part_of_speech', 'meanings_chunks', 'meanings_part_of_speech', 'card_state', 'pitch_accent'],
                            position_length_encoding: 'utf16'
                        })
                    });

                    if (!response.ok) {
                        console.warn(`API request failed for transcript chunk ${i + 1}: ${response.status}`);
                        continue; // Skip this chunk but continue with others
                    }

                    const data = await response.json();
                    const chunkTokens = data.tokens || [];
                    const chunkVocabulary = data.vocabulary || [];

                    // Adjust token positions to global text positions
                    const adjustedTokens = chunkTokens.map(token => {
                        if (token[0] >= 0) { // Has vocabulary
                            return [
                                globalVocabIndex + token[0], // Adjust vocabulary index
                                globalTokenOffset + token[1], // Adjust position
                                token[2] // Keep length
                            ];
                        } else {
                            return [
                                token[0], // Keep as-is for non-vocabulary tokens
                                globalTokenOffset + token[1], // Adjust position
                                token[2] // Keep length
                            ];
                        }
                    });

                    allTokens.push(...adjustedTokens);
                    allVocabulary.push(...chunkVocabulary);

                    globalVocabIndex += chunkVocabulary.length;
                    globalTokenOffset += chunk.length;

                    // Rate limiting between chunks (increased delay to avoid rate limiting)
                    if (i < chunks.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }

                } catch (error) {
                    console.error(`Error processing transcript chunk ${i + 1}:`, error);
                    // Continue with other chunks
                }
            }

            console.log(`Transcript chunked parsing complete: ${allTokens.length} tokens, ${allVocabulary.length} vocabulary entries`);

            // Cache the result
            const result = {
                tokens: allTokens,
                vocabulary: allVocabulary,
                rawText: text
            };
            jpdbCache[cacheKey] = result;
            saveJpdbCache();

            return result;
        }

        async function parseTextInChunks(cleanedText, katakanaWords, originalText) {
            // Split into chunks (smaller to avoid rate limiting)
            const chunks = splitIntoChunks(cleanedText, 200);
            console.log(`Split text into ${chunks.length} chunks for API processing`);

            const allTokens = [];
            const allVocabulary = [];
            let globalTokenOffset = 0;

            // Process each chunk with rate limiting
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                console.log(`Processing chunk ${i + 1}/${chunks.length}: "${chunk.substring(0, 50)}..."`);

                try {
                    const response = await fetch('https://jpdb.io/api/v1/parse', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: chunk,
                            token_fields: ['vocabulary_index', 'position', 'length'],
                            vocabulary_fields: ['sid', 'rid', 'spelling', 'reading', 'meanings', 'card_state'],
                            position_length_encoding: 'utf8'
                        })
                    });

                    if (!response.ok) {
                        console.warn(`API request failed for chunk ${i + 1}: ${response.status}`);
                        continue; // Skip this chunk but continue with others
                    }

                    const data = await response.json();

                    if (data.error) {
                        console.warn(`API error for chunk ${i + 1}: ${data.error_message}`);
                        continue;
                    }

                    // Adjust token positions to account for chunk offset
                    if (data.tokens) {
                        data.tokens.forEach(token => {
                            if (Array.isArray(token) && token.length >= 3) {
                                // Adjust position by adding chunk offset
                                token[1] += globalTokenOffset; // position
                            }
                        });
                        allTokens.push(...data.tokens);
                    }

                    // Add vocabulary (avoid duplicates by checking existing entries)
                    if (data.vocabulary) {
                        data.vocabulary.forEach(vocab => {
                            const existingIndex = allVocabulary.findIndex(existing =>
                                existing[0] === vocab[0] && existing[2] === vocab[2]
                            );
                            if (existingIndex === -1) {
                                allVocabulary.push(vocab);
                            }
                        });
                    }

                } catch (error) {
                    console.warn(`Error processing chunk ${i + 1}:`, error);
                }

                // Rate limiting - increased delay to avoid rate limiting
                if (i < chunks.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                globalTokenOffset += chunk.length;
            }

            console.log(`Processed ${chunks.length} chunks: ${allTokens.length} tokens, ${allVocabulary.length} vocabulary entries`);
            return { tokens: allTokens, vocabulary: allVocabulary, katakanaWords, originalText };
        }

        function splitIntoChunks(text, maxChunkSize) {
            // Try to send entire text as one chunk first (like jpd-breader)
            if (text.length <= maxChunkSize * 2) {
                return [text];
            }

            // If too long, split by sentences/paragraphs to preserve context
            const chunks = [];
            const sentences = text.split(/([„ÄÇÔºÅÔºü\n])/).filter(s => s.trim());

            let currentChunk = '';

            for (const sentence of sentences) {
                if ((currentChunk + sentence).length <= maxChunkSize) {
                    currentChunk += sentence;
                } else {
                    if (currentChunk.trim()) {
                        chunks.push(currentChunk.trim());
                        currentChunk = '';
                    }

                    // If sentence itself is too long, split it at word boundaries
                    if (sentence.length <= maxChunkSize) {
                        currentChunk = sentence;
                    } else {
                        // Split long sentence by words, trying to stay under limit
                        const words = sentence.split(/(\s+)/);
                        let tempChunk = '';

                        for (const word of words) {
                            if ((tempChunk + word).length <= maxChunkSize) {
                                tempChunk += word;
                            } else {
                                if (tempChunk.trim()) {
                                    chunks.push(tempChunk.trim());
                                }
                                tempChunk = word;
                            }
                        }

                        if (tempChunk.trim()) {
                            currentChunk = tempChunk.trim();
                        }
                    }
                }
            }

            if (currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }

            return chunks.filter(chunk => chunk.length > 0);
        }

        function applyHighlightingToChapter(parseData) {
            const readerDiv = document.getElementById('epubReader');
            if (!readerDiv) return;

            try {
                const { tokens, vocabulary, katakanaWords } = parseData;

                // Find the content div that contains the page text
                let contentDiv = readerDiv.querySelector('div[style*="text-align: justify"]');
                if (!contentDiv) {
                    // Fallback: try to find any div with text content
                    const allDivs = readerDiv.querySelectorAll('div');
                    for (const div of allDivs) {
                        if (div.textContent && div.textContent.trim().length > 50) {
                            contentDiv = div;
                            break;
                        }
                    }
                }
                if (!contentDiv) return;

                // Extract paragraphs from the page content (jpd-breader style)
                const paragraphs = paragraphsInNode(contentDiv);
                console.log(`Found ${paragraphs.length} paragraphs in EPUB content`);

                if (paragraphs.length > 0) {
                    const [batches, applied] = parseParagraphs(paragraphs);
                    Promise.allSettled(applied).then(() => {
                        console.log('EPUB highlighting complete');
                        attachPopupHandlers(contentDiv);
                    });
                }

                console.log('Page highlighting applied');

            } catch (error) {
                console.error('Error applying page highlighting:', error);
            }
        }

        function attachPopupHandlers(paragraph) {
            // Attach click handlers to newly created spans
            const vocabSpans = paragraph.querySelectorAll('span[data-vocab-id]');
            vocabSpans.forEach(span => {
                if (span.onclick === null) { // Only attach if not already attached
                    span.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const vocabId = span.dataset.vocabId;
                        const vocabData = vocabDataRegistry.get(vocabId);
                        const word = span.textContent;

                        if (vocabData) {
                            showVocabPopup(vocabData, word, span);
                        } else {
                            console.log('No vocabulary data for:', word);
                        }

                        return false;
                    };
                }
            });
        }

        // Map position from cleaned text back to original text (accounting for removed katakana/punctuation)
        function getOriginalPosition(text, cleanedStart, cleanedLength, katakanaWords) {
            let originalPos = 0;
            let cleanedPos = 0;
            const result = { start: -1, end: -1 };

            // Find start position
            while (originalPos < text.length && cleanedPos < cleanedStart) {
                const char = text[originalPos];
                const isKatakana = katakanaWords.some(kw => originalPos >= kw.startPos && originalPos < kw.endPos);
                const isPunct = /[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char);

                if (!isKatakana && !isPunct) {
                    cleanedPos++;
                }
                originalPos++;
            }
            result.start = originalPos;

            // Find end position
            let charsFound = 0;
            while (originalPos < text.length && charsFound < cleanedLength) {
                const char = text[originalPos];
                const isKatakana = katakanaWords.some(kw => originalPos >= kw.startPos && originalPos < kw.endPos);
                const isPunct = /[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char);

                if (!isKatakana && !isPunct) {
                    charsFound++;
                }
                originalPos++;
            }
            result.end = originalPos;

            return result;
        }

        // JPD-breader style paragraph extraction
        function paragraphsInNode(node, filter = () => true) {
            let offset = 0;
            const fragments = [];
            const paragraphs = [];

            function breakParagraph() {
                // Remove fragments from the end that are just whitespace
                let end = fragments.length - 1;
                for (; end >= 0; end--) {
                    if (fragments[end].node.data.trim().length > 0) break;
                }

                const trimmedFragments = fragments.slice(0, end + 1);

                if (trimmedFragments.length) {
                    paragraphs.push(trimmedFragments);
                }

                fragments.splice(0);
                offset = 0;
            }

            function pushText(text) {
                // Ignore empty text nodes, as well as whitespace at the beginning of the run
                if (text.data.length > 0 && !(fragments.length === 0 && text.data.trim().length === 0)) {
                    fragments.push({
                        start: offset,
                        length: text.length,
                        end: (offset += text.length),
                        node: text,
                        hasRuby: false
                    });
                }
            }

            function traverse(node, hasRuby = false) {
                const display = displayCategory(node);

                if (display === 'block') {
                    breakParagraph();
                }

                if (display === 'none' || display === 'ruby-text' || filter(node) === false) return;

                if (display === 'text') {
                    pushText(node);
                } else {
                    if (display === 'ruby') {
                        hasRuby = true;
                    }

                    for (const child of node.childNodes) {
                        traverse(child, hasRuby);
                    }

                    if (display === 'block') {
                        breakParagraph();
                    }
                }
            }

            traverse(node, false);
            return paragraphs;
        }

        function displayCategory(node) {
            if (node instanceof Text || node instanceof CDATASection) {
                return 'text';
            } else if (node instanceof Element) {
                const display = getComputedStyle(node).display.split(/\s/g);
                if (display[0] === 'none') return 'none';

                if (node.tagName === 'RUBY') return 'ruby';
                if (node.tagName === 'RP') return 'none';
                if (node.tagName === 'RT') return 'ruby-text';
                if (node.tagName === 'RB') return 'inline';

                if (display.some(x => x.startsWith('block'))) return 'block';
                if (display.some(x => x.startsWith('inline'))) return 'inline';

                if (display[0] === 'flex') return 'block';
                if (display[0] === '-webkit-box') return 'block';
                if (display[0] === 'grid') return 'block';
                if (display[0].startsWith('table')) return 'block';
                if (display[0].startsWith('flow')) return 'block';
                if (display[0] === 'ruby') return 'ruby';
                if (display[0].startsWith('ruby-text')) return 'ruby-text';
                if (display[0].startsWith('ruby-base')) return 'inline';
                if (display[0].startsWith('math')) return 'inline';
                if (display.includes('list-item')) return 'block';

                return 'none';
            } else {
                return 'none';
            }
        }

        // JPD-breader style applyTokens function
        function applyTokens(paragraph, tokens) {
            let fragmentIndex = 0;
            let curOffset = 0;
            let fragment = paragraph[fragmentIndex];
            const text = paragraph.map(x => x.node.data).join('');

            for (const token of tokens) {
                if (!fragment) return;

                // Wrap all unparsed fragments that appear before the token
                while (curOffset < token.start) {
                    if (fragment.end > token.start) {
                        // Only the beginning of the node is unparsed. Split it.
                        splitFragment(paragraph, fragmentIndex, token.start);
                    }

                    // Wrap unparsed text
                    wrap(fragment.node, document.createElement('span')); // Unparsed wrapper
                    fragment.node.parentElement.classList.add('jpdb-word', 'unparsed');

                    curOffset += fragment.length;
                    fragment = paragraph[++fragmentIndex];
                    if (!fragment) return;
                }

                // Accumulate fragments until we have enough to fit the current token
                while (curOffset < token.end) {
                    if (fragment.end > token.end) {
                        // Only the beginning of the node is part of the token. Split it.
                        splitFragment(paragraph, fragmentIndex, token.end);
                    }

                    // Wrap token text
                    const className = `jpdb-word ${token.card.state.join(' ')}`;
                    const wrapper = document.createElement('span');
                    wrapper.className = className;
                    wrapper.onmouseenter = onWordHoverStart;
                    wrapper.onmouseleave = onWordHoverStop;

                    const vocabId = `vocab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    // Get paragraph text for sentence context
                    const paragraphText = paragraph.map(x => x.node.data).join('');
                    vocabDataRegistry.set(vocabId, {
                        vocabId: vocabId,  // Store vocabId for retrieval
                        vid: token.card.vid,       // Store vid if available
                        sid: token.card.sid,       // Store sid if available
                        spelling: token.card.spelling,
                        reading: token.card.reading,
                        meanings: token.card.meanings,
                        card_state: token.card.state,
                        sourceText: paragraphText  // Store paragraph text for sentence extraction
                    });
                    wrapper.dataset.vocabId = vocabId;

                    wrap(fragment.node, wrapper);

                    curOffset = fragment.end;
                    fragment = paragraph[++fragmentIndex];
                    if (!fragment) break;
                }
            }

            // Wrap any left-over fragments in unparsed wrappers
            for (const fragment of paragraph.slice(fragmentIndex)) {
                wrap(fragment.node, document.createElement('span'));
                fragment.node.parentElement.classList.add('jpdb-word', 'unparsed');
            }
        }

        function splitFragment(fragments, fragmentIndex, splitOffset) {
            const oldFragment = fragments[fragmentIndex];

            const newNode = oldFragment.node.splitText(splitOffset - oldFragment.start);

            // Insert new fragment
            const newFragment = {
                start: splitOffset,
                end: oldFragment.end,
                length: oldFragment.end - splitOffset,
                node: newNode,
                hasRuby: oldFragment.hasRuby,
            };
            fragments.splice(fragmentIndex + 1, 0, newFragment);

            // Change endpoint of existing fragment accordingly
            oldFragment.end = splitOffset;
            oldFragment.length = splitOffset - oldFragment.start;
        }

        function wrap(node, wrapper) {
            const parent = node.parentElement;
            if (parent) {
                parent.insertBefore(wrapper, node);
                wrapper.appendChild(node);
            }
        }

        function onWordHoverStart(e) {
            // Placeholder for hover functionality
        }

        function onWordHoverStop(e) {
            // Placeholder for hover functionality
        }

        // Batch processing system like jpd-breader
        function createParseBatch(paragraph) {
            return {
                paragraph,
                promise: null, // Will be set when parsing
                abort: null,
                seq: null
            };
        }

        function parseParagraphs(paragraphs) {
            const batches = paragraphs.map(createParseBatch);
            const applied = batches.map(({ paragraph }) =>
                parseTextForHighlightingChunked(paragraph.map(f => f.node.data).join('')).then(tokens => {
                    // Convert our token format to jpd-breader format
                    const jpdbTokens = tokens.tokens.map(t => ({
                        start: t[1],
                        end: t[1] + t[2],
                        length: t[2],
                        card: t[0] >= 0 && tokens.vocabulary[t[0]] ? {
                            vid: tokens.vocabulary[t[0]][0],     // vid
                            sid: tokens.vocabulary[t[0]][1],     // sid
                            spelling: tokens.vocabulary[t[0]][3],
                            reading: tokens.vocabulary[t[0]][4],
                            meanings: tokens.vocabulary[t[0]][7]?.flat() || [],
                            state: Array.isArray(tokens.vocabulary[t[0]][9]) ? tokens.vocabulary[t[0]][9] : [tokens.vocabulary[t[0]][9]]
                        } : null
                    })).filter(t => t.card);

                    applyTokens(paragraph, jpdbTokens);
                }).catch(error => {
                    console.error('Error parsing paragraph:', error);
                })
            );

            return [batches, applied];
        }

        function applyHighlightingToText(textOrElement, parseData) {
            // For sentence parser, create a paragraph and use the jpd-breader approach
            if (typeof textOrElement === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.textContent = textOrElement;
                document.getElementById('highlightedText').appendChild(tempDiv);

                const paragraphs = paragraphsInNode(tempDiv);
                if (paragraphs.length > 0) {
                    const [batches, applied] = parseParagraphs(paragraphs);
                    Promise.allSettled(applied).then(() => {
                        // Move the highlighted content back to the target element
                        const highlightedHTML = tempDiv.innerHTML;
                        document.getElementById('highlightedText').innerHTML = highlightedHTML;
                        attachPopupHandlers(document.getElementById('highlightedText'));
                    });
                }
                return '';
            }
        }

        function extractKatakanaWords(text) {
            // JPDB doesn't parse katakana words, so we need to extract them separately
            // Find sequences of katakana characters (including nakaguro „Éª)
            const katakanaRegex = /[\u30A0-\u30FF„Éª]+/g;
            const katakanaWords = [];

            // Extract katakana words with their positions in the original text
            let match;
            while ((match = katakanaRegex.exec(text)) !== null) {
                const word = match[0];
                const startPos = match.index;
                const endPos = startPos + word.length;

                katakanaWords.push({
                    word: word,
                    startPos: startPos,
                    endPos: endPos
                });
            }

            // Remove katakana from text for JPDB parsing
            const cleanedText = text.replace(katakanaRegex, '');

            return { cleanedText, katakanaWords };
        }

        // Legacy function - kept for compatibility
        function cleanTextForJPDB(text) {
            // Remove punctuation that might confuse JPDB
            return text.replace(/[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/g, '');
        }

        // Legacy function - kept for compatibility
        function getOriginalPosition(text, cleanedStart, cleanedLength, katakanaWords) {
            let originalPos = 0;
            let cleanedPos = 0;
            const result = { start: -1, end: -1 };

            // Find start position
            while (originalPos < text.length && cleanedPos <= cleanedStart) {
                const char = text[originalPos];
                const isKatakana = katakanaWords.some(kw => originalPos >= kw.startPos && originalPos < kw.endPos);
                const isPunct = /[„Äå„Äç„Äé„Äè()ÔºàÔºâ[\]{}„ÄÅ„ÄÇ,.Ôºé!?ÔºÅÔºü\s]/.test(char);

                if (!isKatakana && !isPunct) {
                    if (cleanedPos === cleanedStart) {
                        result.start = originalPos;
                        break;
                    }
                    cleanedPos++;
                }
                originalPos++;
            }

            // Find end position
            result.end = result.start + cleanedLength;
            return result;
        }

        function updateReadingProgress(message) {
            document.getElementById('readingProgress').textContent = message;
        }

        function saveReadingProgress() {
            if (!currentEpub || typeof currentChapter !== 'number' || !currentEpubFile) return;

            try {
                const bookId = currentEpubFile.name;

                const progress = {
                    bookId: bookId,
                    chapterIndex: currentChapter,
                    pageIndex: currentPage,
                    lastRead: new Date().toISOString()
                };

                localStorage.setItem(`epub-progress-${bookId}`, JSON.stringify(progress));
                console.log('Reading progress saved:', progress);

            } catch (error) {
                console.error('Error saving reading progress:', error);
            }
        }

        function loadReadingProgress(bookId) {
            try {
                const saved = localStorage.getItem(`epub-progress-${bookId}`);
                if (saved) {
                    const progress = JSON.parse(saved);
                    // Ensure we have valid indices
                    return {
                        chapterIndex: Math.max(0, progress.chapterIndex || 0),
                        pageIndex: Math.max(0, progress.pageIndex || 0)
                    };
                }
                return null;
            } catch (error) {
                console.error('Error loading reading progress:', error);
                return null;
            }
        }

        // EPUB Event Handlers
        document.getElementById('loadEpubBtn').addEventListener('click', async function() {
            const fileInput = document.getElementById('epubFile');
            const file = fileInput.files[0];

            if (!file) {
                showStatus('Please select an EPUB file first', 'error');
                return;
            }

            if (!apiKey) {
                showStatus('Please set your JPDB API key first', 'error');
                return;
            }

            // Clear any previous EPUB
            if (currentEpub) {
                try {
                    currentEpub.destroy();
                    if (currentEpub.blobUrl) {
                        URL.revokeObjectURL(currentEpub.blobUrl);
                    }
                } catch (e) {
                    console.log('Error destroying previous EPUB:', e);
                }
                currentEpub = null;
            }

            // Clear the reader display
            const readerDiv = document.getElementById('epubReader');
            readerDiv.innerHTML = '';

            await loadEPUB(file);
        });

        document.getElementById('prevChapterBtn').addEventListener('click', function() {
            if (currentEpub && typeof currentChapter === 'number') {
                const chapters = currentEpub.chapters;
                if (currentChapter > 0) {
                    saveReadingProgress();
                    loadChapter(currentChapter - 1);
                }
            }
        });

        document.getElementById('nextChapterBtn').addEventListener('click', function() {
            if (currentEpub && typeof currentChapter === 'number') {
                const chapters = currentEpub.chapters;
                if (currentChapter < chapters.length - 1) {
                    saveReadingProgress();
                    loadChapter(currentChapter + 1);
                }
            }
        });

        document.getElementById('prevPageBtn').addEventListener('click', function() {
            if (currentPage > 0) {
                currentPage--;
                displayPage(currentPage);
                updatePageNavigationButtons();
                updateReadingProgress(`Chapter ${currentChapter + 1} - Page ${currentPage + 1} of ${totalPages}`);

                // Parse text for JPDB highlighting for the new page
                const currentPageContent = chapterPages[currentPage];
                parseChapterText(currentPageContent);
            }
        });

        document.getElementById('nextPageBtn').addEventListener('click', function() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                displayPage(currentPage);
                updatePageNavigationButtons();
                updateReadingProgress(`Chapter ${currentChapter + 1} - Page ${currentPage + 1} of ${totalPages}`);

                // Parse text for JPDB highlighting for the new page
                const currentPageContent = chapterPages[currentPage];
                parseChapterText(currentPageContent);
            }
        });

        // Save progress when page unloads
        window.addEventListener('beforeunload', function() {
            saveReadingProgress();
        });

        // EPUB Parsing Helper Functions
        async function extractTextFromEPUB(zip) {
            const textContent = [];
            const htmlFiles = [];

            // Find all HTML/XHTML files in the EPUB
            Object.keys(zip.files).forEach(filename => {
                if (filename.endsWith('.html') || filename.endsWith('.xhtml') || filename.endsWith('.htm')) {
                    // Skip navigation and other non-content files
                    if (!filename.includes('nav') && !filename.includes('toc') && !filename.includes('cover')) {
                        htmlFiles.push(filename);
                    }
                }
            });

            console.log('Found HTML files:', htmlFiles);

            // Extract text from each HTML file
            for (const filename of htmlFiles) {
                try {
                    const file = zip.files[filename];
                    const content = await file.async('text');

                    // Extract text content from HTML
                    const text = extractTextFromHTML(content);
                    if (text.trim()) {
                        textContent.push(text);
                    }
                } catch (error) {
                    console.warn('Error extracting text from', filename, error);
                }
            }

            return textContent.join('\n\n');
        }

        function extractTextFromHTML(html) {
            // Create a temporary DOM element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            // Remove script and style elements
            const scripts = tempDiv.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());

            // Extract text from paragraphs and other content elements
            const contentElements = tempDiv.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
            const textParts = [];

            contentElements.forEach(el => {
                const text = el.textContent.trim();
                if (text && text.length > 10) { // Skip very short text snippets
                    textParts.push(text);
                }
            });

            // If no structured content found, try to get all text
            if (textParts.length === 0) {
                const allText = tempDiv.textContent.trim();
                if (allText) {
                    textParts.push(allText);
                }
            }

            return textParts.join('\n');
        }

        // Manga Reader Functions
        async function loadManga(file) {
            try {
                console.log('Starting Manga load for file:', file.name, 'size:', file.size, 'type:', file.type);

                if (!file.name.toLowerCase().endsWith('.pdf')) {
                    throw new Error('File must be a PDF (.pdf)');
                }

                // Show loading indicator
                const loadBtn = document.getElementById('loadMangaBtn');
                const loadText = document.getElementById('loadMangaText');
                const loadSpinner = document.getElementById('loadMangaSpinner');
                loadText.textContent = 'Loading PDF...';
                loadSpinner.classList.remove('hidden');
                loadBtn.disabled = true;

                // Show loading overlay on manga display
                showMangaLoadingOverlay('Loading PDF file...');

                currentMangaFile = file;
                mangaPages = [];
                currentMangaPage = 0;

                showStatus('Loading PDF file...', 'info');

                // Load PDF using PDF.js
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                console.log('PDF loaded with', pdf.numPages, 'pages - Rendering at 3x scale for OCR quality');

                // Render all pages at high resolution for OCR quality
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 3.0 }); // High scale for excellent OCR quality

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    const imageData = canvas.toDataURL('image/png');
                    mangaPages.push({
                        imageData: imageData,
                        ocrText: '',
                        pageNumber: pageNum
                    });
                }

                console.log('Rendered', mangaPages.length, 'pages');

                // Show the first page
                displayMangaPage(0);

                // Enable controls
                updateMangaControls();

                // Initialize region selection after DOM update
                setTimeout(() => {
                    const mangaDisplay = document.getElementById('mangaDisplay');
                    if (mangaDisplay && !mangaDisplay.classList.contains('hidden')) {
                        console.log('Manga display is visible, initializing region selection');
                        initRegionSelection();
                    } else {
                        console.error('Manga display is still hidden or not found, cannot initialize region selection');
                    }
                }, 200);

                // Second attempt after longer delay in case first one fails
                setTimeout(() => {
                    if (!document.getElementById('selectionCanvas')) {
                        console.log('First initialization attempt failed, trying again...');
                        initRegionSelection();
                    }
                }, 500);

                // Show OCR controls
                document.getElementById('ocrControls').classList.remove('hidden');

                // OCR will be done on-demand via region selection

                // Hide loading indicators
                loadText.textContent = 'üìñ Load Manga';
                loadSpinner.classList.add('hidden');
                loadBtn.disabled = false;
                hideMangaLoadingOverlay();

                showStatus('Manga loaded successfully! Processing OCR...', 'success');

            } catch (error) {
                console.error('Error loading manga:', error);
                showStatus('Error loading manga: ' + error.message, 'error');

                // Hide loading indicators on error
                const loadBtn = document.getElementById('loadMangaBtn');
                const loadText = document.getElementById('loadMangaText');
                const loadSpinner = document.getElementById('loadMangaSpinner');
                loadText.textContent = 'üìñ Load Manga';
                loadSpinner.classList.add('hidden');
                loadBtn.disabled = false;
                hideMangaLoadingOverlay();
            }
        }

        function displayMangaPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= mangaPages.length) return;

            const page = mangaPages[pageIndex];
            const canvas = document.getElementById('mangaCanvas');
            const ctx = canvas.getContext('2d');

            const img = new Image();
            img.onload = () => {
                const scale = mangaZoom / 100;
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = page.imageData;

            currentMangaPage = pageIndex;
            updateMangaControls();

            // Clear OCR overlays when changing pages
            clearOCROverlays();

            // Reset selection mode when changing pages
            resetSelectionMode();
        }


        function updateMangaControls() {
            const prevBtn = document.getElementById('prevMangaPageBtn');
            const nextBtn = document.getElementById('nextMangaPageBtn');
            const indicator = document.getElementById('mangaPageIndicator');
            const zoomBtns = ['zoomOutBtn', 'zoomInBtn', 'resetZoomBtn'].map(id => document.getElementById(id));
            const zoomIndicator = document.getElementById('zoomIndicator');
            const display = document.getElementById('mangaDisplay');

            if (mangaPages.length > 0) {
                display.classList.remove('hidden');
                prevBtn.disabled = currentMangaPage === 0;
                nextBtn.disabled = currentMangaPage >= mangaPages.length - 1;
                indicator.textContent = `${currentMangaPage + 1} / ${mangaPages.length}`;

                zoomBtns.forEach(btn => btn.disabled = false);
                zoomIndicator.textContent = mangaZoom + '%';
            } else {
                display.classList.add('hidden');
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                indicator.textContent = 'Ready';
                zoomBtns.forEach(btn => btn.disabled = true);
                zoomIndicator.textContent = '100%';
            }
        }

        function zoomManga(factor) {
            mangaZoom = Math.max(25, Math.min(300, mangaZoom * factor));
            displayMangaPage(currentMangaPage);
        }

        function resetMangaZoom() {
            mangaZoom = 100;
            displayMangaPage(currentMangaPage);
        }

        // OCR Region Selection Functions
        function initRegionSelection() {
            const canvas = document.getElementById('mangaCanvas');
            let selectionCanvas = document.getElementById('selectionCanvas');
            const ocrOverlay = document.getElementById('ocrOverlay');

            console.log('initRegionSelection called');
            console.log('mangaCanvas found:', !!canvas);
            console.log('selectionCanvas found:', !!selectionCanvas);
            console.log('ocrOverlay found:', !!ocrOverlay);

            // Debug: check all canvas elements in the document
            const allCanvases = document.querySelectorAll('canvas');
            console.log('All canvas elements:', Array.from(allCanvases).map(c => ({ id: c.id, className: c.className })));

            // Debug: check ocrOverlay children
            if (ocrOverlay) {
                console.log('ocrOverlay children:', Array.from(ocrOverlay.children).map(c => ({ tagName: c.tagName, id: c.id })));
            }

            if (!canvas) {
                console.error('mangaCanvas not found');
                return;
            }

            // Create selection canvas if it doesn't exist
            if (!selectionCanvas) {
                console.log('Creating selection canvas since it was not found');
                const newSelectionCanvas = document.createElement('canvas');
                newSelectionCanvas.id = 'selectionCanvas';
                newSelectionCanvas.className = 'absolute top-0 left-0 pointer-events-auto cursor-crosshair';
                newSelectionCanvas.style.position = 'absolute';
                newSelectionCanvas.style.top = '0';
                newSelectionCanvas.style.left = '0';
                newSelectionCanvas.style.pointerEvents = 'auto';
                newSelectionCanvas.style.cursor = 'crosshair';

                if (ocrOverlay) {
                    ocrOverlay.appendChild(newSelectionCanvas);
                    selectionCanvas = newSelectionCanvas;
                    console.log('Selection canvas created and added to ocrOverlay');
                } else {
                    console.error('Cannot create selection canvas - ocrOverlay not found');
                    return;
                }
            }

            console.log('Initializing region selection successfully');

            // Set up selection canvas to match main canvas
            function resizeSelectionCanvas() {
                const rect = canvas.getBoundingClientRect();
                selectionCanvas.width = rect.width;
                selectionCanvas.height = rect.height;
                selectionCanvas.style.width = rect.width + 'px';
                selectionCanvas.style.height = rect.height + 'px';
                selectionCanvas.style.position = 'absolute';
                selectionCanvas.style.top = '0';
                selectionCanvas.style.left = '0';
                selectionCanvas.style.pointerEvents = 'auto';
                canvasRect = rect;
                console.log('Selection canvas resized:', rect.width, 'x', rect.height);
            }

            resizeSelectionCanvas();
            window.addEventListener('resize', resizeSelectionCanvas);

            // Clear any existing selection
            const ctx = selectionCanvas.getContext('2d');
            ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Mouse event handlers for region selection
            selectionCanvas.addEventListener('mousedown', startSelection);
            selectionCanvas.addEventListener('mousemove', updateSelection);
            selectionCanvas.addEventListener('mouseup', endSelection);

            // Debug: Add listeners for mouse events to see what's happening
            selectionCanvas.addEventListener('mouseenter', () => console.log('Mouse entered selection canvas'));
            selectionCanvas.addEventListener('mouseleave', () => console.log('Mouse left selection canvas'));

            // Listen for mouseup on window to catch mouseup events that happen outside canvas
            window.addEventListener('mouseup', (e) => {
                if (isSelectingRegion && selectionStart) {
                    console.log('Mouseup detected on window, ending selection');
                    endSelection(e);
                }
            });

            console.log('Region selection initialized');
        }

        function startSelection(e) {
            console.log('startSelection called, isSelectingRegion:', isSelectingRegion);
            if (!isSelectingRegion) {
                console.log('Not in selection mode, ignoring');
                return;
            }

            // Update canvas rect to account for any position changes
            const canvas = document.getElementById('mangaCanvas');
            canvasRect = canvas.getBoundingClientRect();

            const rect = canvasRect;
            selectionStart = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            console.log('Selection started at:', selectionStart, 'canvas rect:', rect);
            clearCurrentSelection();
        }

        function updateSelection(e) {
            if (!isSelectingRegion || !selectionStart) return;

            // Update canvas rect to account for any position changes
            const canvas = document.getElementById('mangaCanvas');
            canvasRect = canvas.getBoundingClientRect();

            const rect = canvasRect;
            console.log('updateSelection called with mouse at:', e.clientX, e.clientY, 'canvas rect:', rect);
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const width = Math.abs(currentX - selectionStart.x);
            const height = Math.abs(currentY - selectionStart.y);
            const left = Math.min(currentX, selectionStart.x);
            const top = Math.min(currentY, selectionStart.y);

            console.log('Updating selection:', left, top, width, height);
            updateSelectionVisual(left, top, width, height);
        }

        function endSelection(e) {
            console.log('endSelection called, isSelectingRegion:', isSelectingRegion, 'selectionStart:', selectionStart, 'currentSelection:', currentSelection);
            console.log('Mouse event coordinates:', e.clientX, e.clientY);

            if (!isSelectingRegion || !selectionStart) {
                console.log('Selection not started, ignoring');
                return;
            }

            // If we don't have currentSelection yet (user clicked but didn't drag), create a minimal selection
            if (!currentSelection) {
                const rect = canvasRect;
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                const width = Math.abs(currentX - selectionStart.x);
                const height = Math.abs(currentY - selectionStart.y);
                const left = Math.min(currentX, selectionStart.x);
                const top = Math.min(currentY, selectionStart.y);

                if (width > 2 && height > 2) { // Minimum size threshold
                    currentSelection = { left, top, width, height };
                    console.log('Created selection from click only:', currentSelection);
                } else {
                    console.log('Selection too small, cancelling');
                    resetSelectionMode();
                    return;
                }
            }

            // Temporarily disable selection mode while processing
            const wasSelecting = isSelectingRegion;
            isSelectingRegion = false;

            console.log('Region selected, processing OCR...');
            updateSelectionStatus('Region selected! Processing OCR...');

            // Show loading indicator on selection
            const selectionCanvas = document.getElementById('selectionCanvas');
            const ctx = selectionCanvas.getContext('2d');

            // Draw yellow background
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.fillRect(currentSelection.left, currentSelection.top, currentSelection.width, currentSelection.height);

            // Draw animated border
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(currentSelection.left, currentSelection.top, currentSelection.width, currentSelection.height);

            // Add "Processing..." text
            ctx.fillStyle = '#ff6b35';
            ctx.font = '16px Arial';
            ctx.fillText('üîç Processing OCR...', currentSelection.left + 10, currentSelection.top + 25);

            // Extract the selected region and perform OCR
            try {
                console.log('üéØ Final selection coordinates:', currentSelection);

                // Debug: Show canvas and image info
                const debugCanvas = document.getElementById('mangaCanvas');
                const debugRect = debugCanvas.getBoundingClientRect();
                console.log('üé® Canvas info:', {
                    canvasRect: debugRect,
                    canvasSize: { width: debugCanvas.width, height: debugCanvas.height },
                    selection: currentSelection
                });

            performRegionOCR(currentSelection).finally(() => {
                // Reset selection state after OCR completes
                console.log('OCR processing complete, resetting selection mode');
                resetSelectionMode();
            });
            } catch (error) {
                console.error('Region OCR error:', error);
                updateSelectionStatus('OCR failed. Please try again.');
                clearCurrentSelection();
                resetSelectionMode();
            }
        }

        function updateSelectionVisual(left, top, width, height) {
            const selectionCanvas = document.getElementById('selectionCanvas');
            const ctx = selectionCanvas.getContext('2d');

            console.log('Drawing selection visual:', left, top, width, height, 'canvas size:', selectionCanvas.width, 'x', selectionCanvas.height);

            // Clear previous selection
            ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            if (width > 0 && height > 0) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(left, top, width, height);

                ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
                ctx.fillRect(left, top, width, height);

                currentSelection = { left, top, width, height };
                console.log('Selection visual drawn');
            } else {
                console.log('Selection too small, not drawing');
            }
        }

        function clearCurrentSelection() {
            const selectionCanvas = document.getElementById('selectionCanvas');
            if (selectionCanvas) {
                const ctx = selectionCanvas.getContext('2d');
                ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            }
            currentSelection = null;
        }

        function resetSelectionMode() {
            console.log('Resetting selection mode - called from:', new Error().stack.split('\n')[2]);
            isSelectingRegion = false;
            selectionStart = null;
            currentSelection = null;

            const btn = document.getElementById('selectRegionBtn');
            const selectionCanvas = document.getElementById('selectionCanvas');

            if (btn) {
                btn.textContent = 'üéØ Select Region';
                btn.className = btn.className.replace('bg-red-500', 'bg-blue-500').replace('bg-blue-500', 'bg-blue-500');
                if (!btn.className.includes('bg-blue-500')) {
                    btn.className += ' bg-blue-500';
                }
            }

            if (selectionCanvas) {
                selectionCanvas.style.cursor = 'default';
            }

            clearCurrentSelection();
            updateSelectionStatus('Ready to select region.');
        }

        async function performRegionOCR(selection) {
            if (!currentSelection || !mangaPages[currentMangaPage]) return;

            try {
                // Get the main canvas and create a cropped version
                const mainCanvas = document.getElementById('mangaCanvas');
                const croppedCanvas = document.createElement('canvas');
                const ctx = croppedCanvas.getContext('2d');

                // Calculate the actual image coordinates (accounting for zoom and centering)
                const img = new Image();
                img.src = mangaPages[currentMangaPage].imageData;

                await new Promise(resolve => {
                    img.onload = resolve;
                });

                const scale = mangaZoom / 100;
                const displayWidth = img.width * scale;
                const displayHeight = img.height * scale;

                // Calculate the scaling factor between displayed canvas size and internal canvas size
                const canvasRect = mainCanvas.getBoundingClientRect();
                const canvasScaleX = mainCanvas.width / canvasRect.width;
                const canvasScaleY = mainCanvas.height / canvasRect.height;

                const offsetX = (mainCanvas.width - displayWidth) / 2;
                const offsetY = (mainCanvas.height - displayHeight) / 2;

                console.log('üîç Coordinate transformation setup:', {
                    mangaZoom,
                    scale,
                    imgSize: { width: img.width, height: img.height },
                    displaySize: { width: displayWidth, height: displayHeight },
                    canvasSize: { width: mainCanvas.width, height: mainCanvas.height },
                    canvasDisplayedSize: { width: canvasRect.width, height: canvasRect.height },
                    canvasScaleFactors: { x: canvasScaleX, y: canvasScaleY },
                    centeringOffset: { offsetX, offsetY }
                });

                // Convert selection coordinates to image coordinates
                // Selection coordinates are relative to displayed canvas size, need to scale to internal canvas size
                console.log('üìê Raw selection coordinates (display pixels):', selection);
                console.log('üìê Canvas scaling factors:', { canvasScaleX, canvasScaleY });

                // Scale selection coordinates from display pixels to internal canvas pixels
                const scaledSelection = {
                    left: selection.left * canvasScaleX,
                    top: selection.top * canvasScaleY,
                    width: selection.width * canvasScaleX,
                    height: selection.height * canvasScaleY
                };

                console.log('üìê Scaled selection coordinates (canvas pixels):', scaledSelection);

                const imageX = Math.max(0, (scaledSelection.left - offsetX) / scale);
                const imageY = Math.max(0, (scaledSelection.top - offsetY) / scale);
                const imageWidth = Math.min(scaledSelection.width / scale, img.width - imageX);
                const imageHeight = Math.min(scaledSelection.height / scale, img.height - imageY);

                console.log('üéØ Calculated image coordinates:', {
                    imageX, imageY, imageWidth, imageHeight,
                    maxPossibleX: img.width - imageX,
                    maxPossibleY: img.height - imageY
                });

                // Store displaySelection for later use in OCR (using scaled coordinates)
                const displaySelection = { left: scaledSelection.left, top: scaledSelection.top, width: scaledSelection.width, height: scaledSelection.height };

                console.log('üî¢ Coordinate transformation:', {
                    displaySelection,
                    canvasOffset: { offsetX, offsetY },
                    scale,
                    originalImage: { width: img.width, height: img.height },
                    croppedRegion: { imageX, imageY, imageWidth, imageHeight }
                });

                // DEBUG: Draw a red rectangle on the main canvas to show what region is being cropped
                // Use the scaled coordinates so the rectangle appears in the right place on the displayed canvas
                const mainCtx = mainCanvas.getContext('2d');
                mainCtx.strokeStyle = 'red';
                mainCtx.lineWidth = 3;
                mainCtx.strokeRect(
                    scaledSelection.left,
                    scaledSelection.top,
                    scaledSelection.width,
                    scaledSelection.height
                );
                console.log('üî¥ Drew red rectangle on canvas showing scaled selected region:', scaledSelection);

                // Create cropped canvas with manga-ocr style preprocessing
                croppedCanvas.width = imageWidth;
                croppedCanvas.height = imageHeight;
                console.log('üìê Cropped region size:', imageWidth, 'x', imageHeight);

                // Apply manga-ocr preprocessing: convert to grayscale then back to RGB
                ctx.filter = 'grayscale(100%)';
                ctx.drawImage(img,
                    imageX, imageY, imageWidth, imageHeight,
                    0, 0, imageWidth, imageHeight
                );

                // Reset filter and get the grayscale data
                ctx.filter = 'none';
                const grayscaleData = ctx.getImageData(0, 0, imageWidth, imageHeight);

                // Apply contrast enhancement (manga-ocr style)
                const data = grayscaleData.data;
                for (let i = 0; i < data.length; i += 4) {
                    // Simple contrast boost - manga often has high contrast text
                    const gray = data[i]; // R=G=B in grayscale
                    const enhanced = Math.min(255, gray * 1.2); // Boost contrast
                    data[i] = data[i + 1] = data[i + 2] = enhanced; // Set RGB to enhanced value
                }

                // Put the enhanced image data back
                ctx.putImageData(grayscaleData, 0, 0);

                console.log('üîß Applied manga-ocr style preprocessing (grayscale + contrast enhancement)');

                // Debug: Show preview of cropped region
                const previewImg = new Image();
                previewImg.src = croppedCanvas.toDataURL();
                previewImg.style.maxWidth = '200px';
                previewImg.style.border = '2px solid red';
                previewImg.title = 'OCR Preview - what we are trying to recognize';
                console.log('üñºÔ∏è OCR Preview Image:', previewImg);

                // Debug: Analyze canvas content
                const imageData = ctx.getImageData(0, 0, imageWidth, imageHeight);
                const pixels = imageData.data;
                let hasContent = false;
                let darkPixels = 0;
                let totalPixels = pixels.length / 4;

                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
                    const brightness = (r + g + b) / 3;
                    if (brightness < 200) { // Consider pixel "dark" if brightness < 200
                        darkPixels++;
                        hasContent = true;
                    }
                }

                console.log('üìä Canvas content analysis:', {
                    totalPixels,
                    darkPixels,
                    darkPixelRatio: (darkPixels / totalPixels).toFixed(3),
                    hasContent,
                    canvasDimensions: `${imageWidth}x${imageHeight}`
                });

                if (!hasContent) {
                    console.warn('‚ö†Ô∏è Canvas appears to be mostly empty/white - OCR may not find text');
                }

                // Perform OCR on the preprocessed cropped region
                console.log('üîç Starting OCR on preprocessed cropped region:', {
                    imageX, imageY, imageWidth, imageHeight,
                    croppedCanvasSize: { width: croppedCanvas.width, height: croppedCanvas.height }
                });

                // Try PaddleOCR first, then enhanced Tesseract
                let text;
                let ocrMethod = 'Unknown';

                // Check if PaddleOCR is available
                if (window.paddlejs && window.paddlejs.ocr) {
                try {
                        console.log('üéØ Trying PaddleOCR (primary)...');

                    // Initialize PaddleOCR with built-in models
                        const ocr = window.paddlejs.ocr;
                        console.log('Initializing PaddleOCR...');
                    await ocr.init();

                    // Convert canvas to image element for PaddleOCR
                    const img = new Image();
                    img.src = croppedCanvas.toDataURL();
                    await new Promise(resolve => {
                        img.onload = resolve;
                    });

                    const res = await ocr.recognize(img);
                    text = Array.isArray(res.text) ? res.text.join('\n') : res.text;
                        ocrMethod = 'PaddleOCR';
                    console.log('‚úÖ PaddleOCR successful, text length:', text.length);

                } catch (paddleError) {
                        console.log('‚ö†Ô∏è PaddleOCR failed, falling back to enhanced Tesseract:', paddleError.message);
                        // Continue to Tesseract fallback below
                    }
                } else {
                    console.log('üîÑ PaddleOCR not available, using enhanced Tesseract...');
                }

                // Prepare PaddleOCR input from original image data
                // PaddleOCR models are trained on raw images, preprocessing might hurt recognition
                const originalCanvas = document.createElement('canvas');
                const originalCtx = originalCanvas.getContext('2d');
                originalCanvas.width = croppedCanvas.width;
                originalCanvas.height = croppedCanvas.height;

                // Copy the original (unprocessed) region from the main canvas
                const mainCanvasCtx = mainCanvas.getContext('2d');
                const originalImageData = mainCanvasCtx.getImageData(
                    Math.floor(displaySelection.left),
                    Math.floor(displaySelection.top),
                    Math.floor(displaySelection.width),
                    Math.floor(displaySelection.height)
                );

                originalCtx.putImageData(originalImageData, 0, 0);

                        // Scale up the cropped region for better OCR quality
                        const ocrScaleFactor = 1.5; // Scale up by 1.5x for OCR (reduced to stay under 1MB API limit)
                        const scaledCanvas = document.createElement('canvas');
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCanvas.width = Math.round(originalImageData.width * ocrScaleFactor);
                        scaledCanvas.height = Math.round(originalImageData.height * ocrScaleFactor);

                        // Use high-quality scaling
                        scaledCtx.imageSmoothingEnabled = true;
                        scaledCtx.imageSmoothingQuality = 'high';
                        scaledCtx.drawImage(originalCanvas, 0, 0, scaledCanvas.width, scaledCanvas.height);

                        // Get scaled image data
                        const scaledImageData = scaledCtx.getImageData(0, 0, scaledCanvas.width, scaledCanvas.height);

                        console.log('üîß Preparing OCR input - Scaled up for quality:', {
                            originalSize: `${originalImageData.width}x${originalImageData.height}`,
                            scaledSize: `${scaledCanvas.width}x${scaledCanvas.height}`,
                            scaleFactor: ocrScaleFactor,
                            scaledDataLength: scaledImageData.data.length,
                            estimatedFileSize: 'Calculating...'
                        });

                        // Calculate estimated file size
                        scaledCanvas.toBlob((blob) => {
                            const sizeKB = (blob.size / 1024).toFixed(1);
                            console.log(`üìä OCR image file size: ${sizeKB} KB (API limit: 1024 KB)`);
                        });

                        const paddleInput = {
                            data: scaledImageData.data, // Use scaled RGBA data for better OCR
                            width: scaledCanvas.width,
                            height: scaledCanvas.height,
                        };

                // Use OCR.space API for high-quality Japanese OCR
                console.log('üîß Using OCR.space API for Japanese text recognition...');


                // Use OCR.space API for Japanese text recognition
                if (!text) {
                    try {
                        console.log('üîß Using OCR.space API for Japanese text recognition...');

                        // Send the high-resolution scaled image to OCR.space (using JPEG for smaller file size)
                        // Try with high quality first, fallback to lower quality if still too large
                        let imageDataURL = scaledCanvas.toDataURL('image/jpeg', 0.9);

                        // Check file size and reduce quality if needed
                        const testBlob = await new Promise(resolve => {
                            scaledCanvas.toBlob(resolve, 'image/jpeg', 0.9);
                        });

                        if (testBlob.size > 900 * 1024) { // If over 900KB, use lower quality
                            console.log(`‚ö†Ô∏è Image too large (${(testBlob.size/1024).toFixed(1)} KB), reducing quality...`);
                            imageDataURL = scaledCanvas.toDataURL('image/jpeg', 0.7);
                        }

                        const ocrText = await performOCRWithSpaceAPI(imageDataURL);

                        text = ocrText;
                        ocrMethod = 'OCR.space API (Japanese)';
                        console.log('‚úÖ OCR.space API successful, extracted text:', JSON.stringify(text));

                    } catch (ocrError) {
                        console.error('‚ùå OCR.space API failed:', ocrError);
                        console.log('‚ö†Ô∏è OCR functionality unavailable - API error');
                        text = '';
                        ocrMethod = 'Failed';
                    }
                }

                console.log('üìù Raw OCR result:', JSON.stringify(text));

                // Apply manga-ocr style post-processing
                let processedText = text;
                processedText = processedText.replace(/\s+/g, ''); // Remove all whitespace like "".join(text.split())
                processedText = processedText.replace(/‚Ä¶/g, '...'); // Replace ‚Ä¶ with ...
                processedText = processedText.replace(/„Éª{2,}/g, (match) => '.'.repeat(match.length)); // Handle repeated dots
                processedText = processedText.replace(/\.{2,}/g, (match) => '.'.repeat(match.length)); // Handle repeated periods

                // Filter out potential furigana (very short text segments that might be ruby annotations)
                // Split by newlines and filter out segments shorter than 2 characters
                const lines = processedText.split('\n');
                const filteredLines = lines.filter(line => {
                    const trimmed = line.trim();
                    return trimmed.length >= 2 || /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(trimmed); // Keep if >= 2 chars or contains Japanese
                });
                processedText = filteredLines.join('\n');

                console.log('üîÑ After manga-ocr post-processing:', JSON.stringify(processedText));
                console.log('üìä OCR text analysis:', {
                    rawLength: text.length,
                    processedLength: processedText.length,
                    hasJapanese: /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(processedText),
                    lines: text.split('\n').length,
                    rawPreview: text.substring(0, 50).replace(/\n/g, '\\n'),
                    processedPreview: processedText.substring(0, 50)
                });

                if (processedText.trim()) {
                    console.log('‚úÖ OCR text found, proceeding to JPDB parsing...');

                    // Apply JPDB highlighting to the OCR text
                    console.log('üîÑ Sending to JPDB parser:', processedText);
                    const parseData = await parseTextForHighlightingChunked(processedText);

                    console.log('üìã JPDB parse result:', {
                        tokensCount: parseData.tokens.length,
                        vocabularyCount: parseData.vocabulary.length,
                        firstFewTokens: parseData.tokens.slice(0, 5),
                        firstFewVocab: parseData.vocabulary.slice(0, 3).map(v => ({
                            id: v[0],
                            spelling: v[3],
                            reading: v[4],
                            meaningsCount: v[7]?.length || 0,
                            cardState: v[9]
                        }))
                    });

                    const jpdbTokens = parseData.tokens.map(t => ({
                        start: t[1],
                        end: t[1] + t[2],
                        length: t[2],
                        card: t[0] >= 0 && parseData.vocabulary[t[0]] ? {
                            vid: parseData.vocabulary[t[0]][0],     // vid
                            sid: parseData.vocabulary[t[0]][1],     // sid
                            spelling: parseData.vocabulary[t[0]][3],
                            reading: parseData.vocabulary[t[0]][4],
                            meanings: parseData.vocabulary[t[0]][7]?.flat() || [],
                            state: Array.isArray(parseData.vocabulary[t[0]][9]) ? parseData.vocabulary[t[0]][9] : [parseData.vocabulary[t[0]][9]]
                        } : null
                    })).filter(t => t.card);

                    console.log('üéØ JPDB tokens with vocabulary:', jpdbTokens.map(t => ({
                        text: processedText.substring(t.start, t.end),
                        card: t.card ? {
                            spelling: t.card.spelling,
                            state: t.card.state
                        } : null
                    })));

                    // Create a temporary paragraph and apply highlighting
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = processedText;
                    document.body.appendChild(tempDiv);

                    console.log('üîß Applying JPDB highlighting to DOM...');
                    const paragraphs = paragraphsInNode(tempDiv);
                    console.log('üìÑ Found paragraphs:', paragraphs.length);

                    if (paragraphs.length > 0) {
                        const [batches, applied] = parseParagraphs(paragraphs);
                        await Promise.allSettled(applied);

                        const highlightedHTML = tempDiv.innerHTML;
                        console.log('‚ú® Final highlighted HTML:', highlightedHTML);
                        console.log('üìè HTML analysis:', {
                            length: highlightedHTML.length,
                            hasSpans: highlightedHTML.includes('<span'),
                            spanCount: (highlightedHTML.match(/<span/g) || []).length,
                            preview: highlightedHTML.substring(0, 200) + '...'
                        });

                        createOCRTextDisplay(highlightedHTML);
                    } else {
                        console.log('‚ùå No paragraphs found in OCR text');
                    }

                    document.body.removeChild(tempDiv);
                }

                if (processedText.trim()) {
                    updateSelectionStatus(`OCR complete! Found ${processedText.length} character(s) of Japanese text using ${ocrMethod}.`);
                } else {
                    updateSelectionStatus('OCR complete! No text found in selected region.');
                }
                // Don't clear selection immediately - let user see the result
                setTimeout(() => clearCurrentSelection(), 2000);

            } catch (error) {
                console.error('OCR processing error:', error);
                updateSelectionStatus('OCR failed. Please try again.');
                clearCurrentSelection();
            }
        }

        function createOCRTextOverlay(selection, highlightedText) {
            console.log('Creating OCR overlay at position:', selection, 'with text length:', highlightedText.length);
            const ocrOverlay = document.getElementById('ocrOverlay');

            // Create overlay container
            const overlayDiv = document.createElement('div');
            overlayDiv.className = 'ocr-overlay';
            overlayDiv.style.left = selection.left + 'px';
            overlayDiv.style.top = selection.top + 'px';
            overlayDiv.style.width = selection.width + 'px';
            overlayDiv.style.minHeight = selection.height + 'px';

            // Create text bubble
            const textBubble = document.createElement('div');
            textBubble.className = 'ocr-text-bubble';
            textBubble.innerHTML = highlightedText;
            textBubble.title = 'Click to see dictionary definitions';

            overlayDiv.appendChild(textBubble);
            ocrOverlay.appendChild(overlayDiv);
            console.log('OCR overlay created and added to DOM');

            // Attach popup handlers
            attachPopupHandlers(textBubble);

            // Store overlay for cleanup
            ocrOverlays.push(overlayDiv);
        }

        function createOCRTextDisplay(highlightedText) {
            console.log('Displaying OCR results with length:', highlightedText.length);
            const resultsDisplay = document.getElementById('ocrResultsDisplay');
            const resultsContent = document.getElementById('ocrResultsContent');

            // Set the highlighted text
            resultsContent.innerHTML = highlightedText;

            // Show the results display
            resultsDisplay.classList.remove('hidden');

            // Attach popup handlers for dictionary functionality
            attachPopupHandlers(resultsContent);

            console.log('OCR results displayed with JPDB highlighting');
        }

        function clearOCROverlays() {
            const ocrOverlay = document.getElementById('ocrOverlay');
            ocrOverlay.innerHTML = '';
            ocrOverlays = [];
            updateSelectionStatus('Overlays cleared. Ready to select region.');
        }

        function updateSelectionStatus(message) {
            const status = document.getElementById('selectionStatus');
            status.textContent = message;
        }

        function showMangaLoadingOverlay(message = 'Loading...') {
            const display = document.getElementById('mangaDisplay');
            const existingOverlay = display.querySelector('.manga-loading-overlay');

            if (existingOverlay) {
                existingOverlay.remove();
            }

            const overlay = document.createElement('div');
            overlay.className = 'manga-loading-overlay';
            overlay.innerHTML = `
                <div class="manga-loading-content">
                    <div class="manga-spinner"></div>
                    <p>${message}</p>
                </div>
            `;

            display.appendChild(overlay);
        }

        function hideMangaLoadingOverlay() {
            const display = document.getElementById('mangaDisplay');
            const overlay = display.querySelector('.manga-loading-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function splitIntoChapters(text) {
            // Simple chapter splitting based on common patterns
            const chapters = [];
            const lines = text.split('\n').filter(line => line.trim());

            let currentChapter = [];
            let chapterStart = true;

            for (const line of lines) {
                // Check if this looks like a chapter start
                const isChapterStart = /^Á¨¨[‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ]+Á´†/.test(line) ||
                                      /^chapter\s+\d+/i.test(line) ||
                                      /^chapter\s+[‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ]+/i.test(line) ||
                                      line.length < 50 && (line.includes('Á´†') || line.includes('Á´†'));

                if (isChapterStart && currentChapter.length > 0) {
                    // Save previous chapter
                    chapters.push(currentChapter.join('\n'));
                    currentChapter = [];
                }

                currentChapter.push(line);
            }

            // Add the last chapter
            if (currentChapter.length > 0) {
                chapters.push(currentChapter.join('\n'));
            }

            // If no chapters were detected, treat the whole text as one chapter
            if (chapters.length === 0) {
                chapters.push(text);
            }

            return chapters;
        }

        function extractMetadata(zip) {
            // Try to extract basic metadata from the EPUB
            try {
                const containerFile = zip.files['META-INF/container.xml'];
                if (containerFile) {
                    // This is a simplified extraction - real EPUB parsing would be more complex
                    return { title: 'EPUB Book', author: 'Unknown' };
                }
            } catch (error) {
                console.warn('Could not extract EPUB metadata:', error);
            }

            return { title: 'EPUB Book', author: 'Unknown' };
        }

        // Initialize on page load (first listener)
        document.addEventListener('DOMContentLoaded', function() {
            // Check if epub.js loaded
            setTimeout(() => {
                if (typeof ePub === 'undefined') {
                    console.error('epub.js library failed to load');
                    showStatus('Warning: epub.js library not loaded. EPUB reading may not work.', 'error');
                } else {
                    console.log('epub.js library loaded successfully');
                }
            }, 2000);

            // Manga Reader event listeners
            document.getElementById('loadMangaBtn').addEventListener('click', function() {
                const fileInput = document.getElementById('mangaFile');
                const file = fileInput.files[0];
                if (file) {
                    loadManga(file);
                } else {
                    showStatus('Please select a PDF file first', 'error');
                }
            });

            document.getElementById('prevMangaPageBtn').addEventListener('click', function() {
                displayMangaPage(currentMangaPage - 1);
            });

            document.getElementById('nextMangaPageBtn').addEventListener('click', function() {
                displayMangaPage(currentMangaPage + 1);
            });

            document.getElementById('zoomInBtn').addEventListener('click', function() {
                zoomManga(1.25);
            });

            document.getElementById('zoomOutBtn').addEventListener('click', function() {
                zoomManga(0.8);
            });

            document.getElementById('resetZoomBtn').addEventListener('click', function() {
                resetMangaZoom();
            });

            // OCR Region Selection event listeners
            document.getElementById('selectRegionBtn').addEventListener('click', function() {
                console.log('Select region button clicked');

                // Try to initialize region selection if not already done
                if (!document.getElementById('selectionCanvas')) {
                    console.log('Selection canvas not found, trying to initialize...');
                    initRegionSelection();
                }

                const selectionCanvas = document.getElementById('selectionCanvas');
                console.log('selectionCanvas exists after init check:', !!selectionCanvas);

                if (!selectionCanvas) {
                    console.error('Cannot enter selection mode - selection canvas not available');
                    updateSelectionStatus('Error: Selection canvas not available. Please refresh and try again.');
                    return;
                }

                isSelectingRegion = !isSelectingRegion;
                const btn = document.getElementById('selectRegionBtn');

                if (isSelectingRegion) {
                    console.log('Entering selection mode');
                    btn.textContent = 'üéØ Cancel Selection';
                    btn.className = btn.className.replace('bg-blue-500', 'bg-red-500');
                    selectionCanvas.style.cursor = 'crosshair';
                    updateSelectionStatus('Click and drag to select a region for OCR');
                } else {
                    console.log('Exiting selection mode');
                    btn.textContent = 'üéØ Select Region';
                    btn.className = btn.className.replace('bg-red-500', 'bg-blue-500');
                    selectionCanvas.style.cursor = 'default';
                    clearCurrentSelection();
                    updateSelectionStatus('Selection cancelled. Ready to select region.');
                }
            });

            document.getElementById('clearOverlaysBtn').addEventListener('click', function() {
                clearOCROverlays();
            });

            // Keyboard shortcuts for Manga Reader
            document.addEventListener('keydown', function(e) {
                // Only handle keyboard shortcuts when manga is loaded
                if (mangaPages.length === 0) return;

                switch (e.key) {
                    case 'ArrowLeft':
                    case 'a':
                        e.preventDefault();
                        displayMangaPage(currentMangaPage - 1);
                        break;
                    case 'ArrowRight':
                    case 'd':
                        e.preventDefault();
                        displayMangaPage(currentMangaPage + 1);
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        zoomManga(1.25);
                        break;
                    case '-':
                        e.preventDefault();
                        zoomManga(0.8);
                        break;
                    case '0':
                        e.preventDefault();
                        resetMangaZoom();
                        break;
                }
            });

            // Video Player event listeners
            document.getElementById('loadVideoBtn').addEventListener('click', loadVideo);
            document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);

            // Video player subtitle updates
            const videoPlayer = document.getElementById('videoPlayer');
            videoPlayer.addEventListener('timeupdate', updateSubtitles);
            videoPlayer.addEventListener('loadeddata', () => {
                // Just update transcript display if subtitles are loaded (no auto-parsing)
                if (subtitleData.length > 0) {
                    updateTranscriptDisplayForSubtitles();
                }
            });

            // Transcript controls
            document.getElementById('generateTranscriptBtn').addEventListener('click', generateTranscript);
            document.getElementById('autoScrollBtn').addEventListener('click', toggleAutoScroll);
            document.getElementById('searchTranscriptBtn').addEventListener('click', searchTranscript);

        });

        // Global function for onclick handlers
        async function saveOcrApiKey() {
            const keyInput = document.getElementById('ocrApiKey');
            const ocrApiKey = keyInput.value.trim();

            if (ocrApiKey) {
                localStorage.setItem('ocr-space-api-key', ocrApiKey);
                showStatus('OCR.space API key saved!', 'success');
            } else {
                showStatus('Please enter an OCR.space API key', 'error');
            }
        }

        async function testOcrConnection() {
            const ocrApiKey = localStorage.getItem('ocr-space-api-key');
            if (!ocrApiKey) {
                showStatus('Please enter and save an OCR.space API key first', 'error');
                return;
            }

            try {
                showStatus('Testing OCR.space connection...', 'info');

                // Create a simple test image with visible text
                const testCanvas = document.createElement('canvas');
                const testCtx = testCanvas.getContext('2d');
                testCanvas.width = 200;
                testCanvas.height = 50;

                // Fill with white background
                testCtx.fillStyle = 'white';
                testCtx.fillRect(0, 0, 200, 50);

                // Add some visible test text (English for testing)
                testCtx.fillStyle = 'black';
                testCtx.font = '20px Arial';
                testCtx.fillText('TEST', 10, 30);

                const testImageDataURL = testCanvas.toDataURL('image/png');

                console.log('üß™ Testing OCR.space API with test image...');

                // Test the OCR API with the test image
                const ocrText = await performOCRWithSpaceAPI(testImageDataURL);

                if (ocrText || ocrText === '') {
                    showStatus('OCR.space connection successful! ‚úì', 'success');
                    console.log('OCR.space test result:', ocrText);
                } else {
                    showStatus('OCR.space API responded but returned no text', 'warning');
                }

            } catch (error) {
                showStatus(`OCR.space connection error: ${error.message}`, 'error');
                console.error('OCR.space test failed:', error);
            }
        }

        function toggleOCRDebug() {
            const debugContainer = document.getElementById('ocrImageDebug');
            const button = debugContainer.querySelector('button');

            if (debugContainer.classList.contains('hidden')) {
                debugContainer.classList.remove('hidden');
                button.textContent = 'Hide Debug';
            } else {
                debugContainer.classList.add('hidden');
                button.textContent = 'Show Debug';
            }
        }

        // Video Player Functions
        function loadVideo() {
            const videoFileInput = document.getElementById('videoFile');
            const subtitleFileInput = document.getElementById('subtitleFile');
            const videoPlayer = document.getElementById('videoPlayer');
            const videoContainer = document.getElementById('videoContainer');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const videoStatus = document.getElementById('videoStatus');

            if (!videoFileInput.files[0]) {
                updateVideoStatus('Please select a video file', 'error');
                return;
            }

            currentVideoFile = videoFileInput.files[0];
            currentSubtitleFile = subtitleFileInput.files[0] || null;

            const videoURL = URL.createObjectURL(currentVideoFile);
            videoPlayer.src = videoURL;

            videoPlayer.onloadedmetadata = () => {
                videoDuration = videoPlayer.duration;
                videoContainer.classList.remove('hidden');
                playPauseBtn.disabled = false;
                updateVideoStatus(`Video loaded: ${currentVideoFile.name}`, 'success');

                // Load subtitles if available
                if (currentSubtitleFile) {
                    loadSubtitles(currentSubtitleFile);
                }
            };

            videoPlayer.onerror = () => {
                updateVideoStatus('Error loading video', 'error');
            };
        }

        function updateVideoStatus(message, type = 'info') {
            const videoStatus = document.getElementById('videoStatus');
            videoStatus.textContent = message;
            videoStatus.className = `px-3 py-2 rounded-lg ${
                type === 'success' ? 'bg-green-100 text-green-700' :
                type === 'error' ? 'bg-red-100 text-red-700' :
                'bg-gray-100 text-gray-700'
            }`;
        }

        function togglePlayPause() {
            const videoPlayer = document.getElementById('videoPlayer');
            const playPauseBtn = document.getElementById('playPauseBtn');

            if (videoPlayer.paused) {
                videoPlayer.play();
                playPauseBtn.textContent = '‚è∏Ô∏è Pause';
            } else {
                videoPlayer.pause();
                playPauseBtn.textContent = '‚ñ∂Ô∏è Play';
            }
        }

        function loadSubtitles(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                subtitleData = parseSubtitles(content, file.name.split('.').pop());
                console.log('Subtitles loaded:', subtitleData.length, 'entries');

                if (subtitleData.length > 0) {
                    updateVideoStatus(`Video + subtitles loaded (${subtitleData.length} subtitle entries)`, 'success');
                    document.getElementById('subtitleOverlay').classList.remove('hidden');

                    // Show transcript panel with basic subtitle display (no auto-parsing)
                    updateTranscriptDisplayForSubtitles();
                }
            };
            reader.readAsText(file);
        }

        function cleanSubtitleText(text) {
            // Remove parenthesized text like („ÉÜ„É≠„ÉÉ„Éó), („Éû„Çπ„Çø„Éº), etc.
            text = text.replace(/\([^)]*\)/g, '').trim();

            // Remove bracketed text like {„ÉÜ„É≠„ÉÉ„Éó}, etc.
            text = text.replace(/\{[^}]*\}/g, '').trim();

            // Clean up extra whitespace
            text = text.replace(/\s+/g, ' ').trim();

            return text;
        }

        function parseSubtitles(content, format) {
            const subtitles = [];

            if (format === 'srt') {
                // Parse SRT format
                const blocks = content.split('\n\n');
                for (const block of blocks) {
                    const lines = block.trim().split('\n');
                    if (lines.length >= 3) {
                        const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
                        if (timeMatch) {
                            const startTime = timeToSeconds(timeMatch[1]);
                            const endTime = timeToSeconds(timeMatch[2]);
                            const rawText = lines.slice(2).join(' ').trim();
                            const cleanedText = cleanSubtitleText(rawText);
                            subtitles.push({
                                start: startTime,
                                end: endTime,
                                rawText: rawText,
                                text: cleanedText
                            });
                        }
                    }
                }
            } else if (format === 'vtt') {
                // Parse WebVTT format
                const lines = content.split('\n');
                let i = 0;
                while (i < lines.length) {
                    if (lines[i].includes('-->')) {
                        const timeMatch = lines[i].match(/(\d{2}:\d{2}:\d{2}\.\d{3}) --> (\d{2}:\d{2}:\d{2}\.\d{3})/);
                        if (timeMatch) {
                            const startTime = timeToSeconds(timeMatch[1]);
                            const endTime = timeToSeconds(timeMatch[2]);
                            let rawText = '';
                            i++;
                            while (i < lines.length && lines[i].trim() && !lines[i].includes('-->')) {
                                rawText += lines[i] + ' ';
                                i++;
                            }
                            rawText = rawText.trim();
                            const cleanedText = cleanSubtitleText(rawText);
                            subtitles.push({
                                start: startTime,
                                end: endTime,
                                rawText: rawText,
                                text: cleanedText
                            });
                        }
                    }
                    i++;
                }
            }

            return subtitles;
        }

        function timeToSeconds(timeStr) {
            // Convert SRT (00:00:00,000) or VTT (00:00:00.000) to seconds
            const parts = timeStr.replace(',', '.').split(':');
            return parseFloat(parts[0]) * 3600 + parseFloat(parts[1]) * 60 + parseFloat(parts[2]);
        }

        function updateSubtitles() {
            const videoPlayer = document.getElementById('videoPlayer');
            const subtitleText = document.getElementById('subtitleText');
            const currentTime = videoPlayer.currentTime;

            // Find current subtitle
            let newIndex = -1;
            for (let i = 0; i < subtitleData.length; i++) {
                if (currentTime >= subtitleData[i].start && currentTime <= subtitleData[i].end) {
                    newIndex = i;
                    break;
                }
            }

            if (newIndex !== currentSubtitleIndex) {
                currentSubtitleIndex = newIndex;
                if (newIndex >= 0) {
                    // Use cleaned text for better readability in subtitles
                    subtitleText.textContent = subtitleData[newIndex].text;
                    document.getElementById('subtitleOverlay').classList.remove('hidden');

                    // Auto-scroll transcript to current subtitle
                    if (autoScrollEnabled) {
                        scrollToSubtitle(newIndex);
                    }
                } else {
                    subtitleText.textContent = '';
                    document.getElementById('subtitleOverlay').classList.add('hidden');
                }
            }
        }

        function scrollToSubtitle(index) {
            // Update the transcript display to center on the given subtitle index
            updateTranscriptDisplay(index);
        }

        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const autoScrollBtn = document.getElementById('autoScrollBtn');
            autoScrollBtn.textContent = autoScrollEnabled ? 'üîÑ Auto-scroll ON' : 'üîÑ Auto-scroll OFF';
            autoScrollBtn.className = autoScrollEnabled ?
                'bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm transition-colors' :
                'bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm transition-colors';
        }

        async function generateTranscript() {
            if (!subtitleData.length) {
                console.log('No subtitles to generate transcript from');
                return;
            }

            // Check cache first
            const transcriptCacheKey = `${currentVideoFile?.name || 'video'}_${currentSubtitleFile?.name || 'subs'}`;
            if (transcriptCache[transcriptCacheKey]) {
                console.log('‚úÖ Using cached transcript');
                displayTranscript(transcriptCache[transcriptCacheKey]);
                return;
            }

            const transcriptContainer = document.getElementById('transcriptContainer');
            const transcriptContent = document.getElementById('transcriptContent');

            // Combine all cleaned subtitle text for JPDB parsing
            const fullTranscript = subtitleData.map(s => s.text).filter(text => text.trim().length > 0).join(' ');
            console.log('Generating transcript from cleaned subtitles, length:', fullTranscript.length);
            console.time('Transcript Generation');

            try {
                // Parse the full transcript with chunking
                const parseData = await parseTextForHighlightingChunked(fullTranscript);
                console.log('Transcript JPDB parse result:', parseData.tokens.length, 'tokens,', parseData.vocabulary.length, 'vocabulary entries');

                // PERFORMANCE OPTIMIZATION: Generate highlighting using existing parseData (no additional API calls)
                console.time('Subtitle Highlighting');
                const subtitleHighlights = generateHighlightsFromParseData(subtitleData, parseData, fullTranscript);
                console.timeEnd('Subtitle Highlighting');

                // Create transcript data structure with vocab registry
                const transcriptData = {
                    subtitles: subtitleData,
                    highlights: subtitleHighlights,
                    vocabRegistry: Array.from(vocabDataRegistry.entries()), // Include vocab data for popups
                    timestamp: Date.now()
                };

                // Cache the result
                transcriptCache[transcriptCacheKey] = transcriptData;
                saveTranscriptCache();

                // Display the transcript
                displayTranscript(transcriptData);

                // Hide the parse button since parsing is complete
                document.getElementById('generateTranscriptBtn').classList.add('hidden');

                console.timeEnd('Transcript Generation');
                console.log('Transcript generated with JPDB highlighting');

            } catch (error) {
                console.error('Error generating transcript:', error);
                transcriptContent.innerHTML = '<div class="text-red-600 text-xs">Error generating transcript</div>';
                transcriptContainer.classList.remove('hidden');
            }
        }

        function displayTranscript(transcriptData) {
            const transcriptContainer = document.getElementById('transcriptContainer');
            const transcriptContent = document.getElementById('transcriptContent');

            // Restore vocab registry data from cache
            if (transcriptData.vocabRegistry) {
                vocabDataRegistry.clear();
                transcriptData.vocabRegistry.forEach(([key, value]) => {
                    vocabDataRegistry.set(key, value);
                });
                console.log(`‚úÖ Restored ${transcriptData.vocabRegistry.length} vocab registry entries from cache`);
            }

            // Store the full transcript data
            transcriptContent.dataset.fullTranscript = JSON.stringify(transcriptData);

            // Initially show current subtitle and a few around it
            updateTranscriptDisplay(0);

            transcriptContainer.classList.remove('hidden');
            transcriptParsed = true;

            // Attach popup handlers
            attachPopupHandlers(transcriptContent);
        }

        function updateTranscriptDisplayForSubtitles(centerIndex = 0) {
            const transcriptContainer = document.getElementById('transcriptContainer');
            const transcriptContent = document.getElementById('transcriptContent');
            const generateBtn = document.getElementById('generateTranscriptBtn');

            if (!subtitleData.length) {
                transcriptContainer.classList.add('hidden');
                return;
            }

            // Show transcript container with basic subtitle display
            transcriptContainer.classList.remove('hidden');

            // Create transcript HTML for ALL subtitles (allow scrolling through entire transcript)
            let transcriptHTML = '';

            for (let i = 0; i < subtitleData.length; i++) {
                const subtitle = subtitleData[i];
                if (!subtitle.text.trim()) continue;

                const isCurrent = (i === centerIndex);
                const bgClass = isCurrent ? 'bg-yellow-100 border-yellow-400' : 'bg-white border-blue-300';

                transcriptHTML += `<div class="subtitle-entry mb-2 p-2 rounded border-l-3 ${bgClass}" data-start="${subtitle.start}" data-end="${subtitle.end}" data-index="${i}">`;
                transcriptHTML += `<div class="text-xs text-gray-500 mb-1">${formatTime(subtitle.start)}</div>`;
                transcriptHTML += `<div class="subtitle-text text-xs">${subtitle.text}</div>`;
                transcriptHTML += '</div>';
            }

            transcriptContent.innerHTML = transcriptHTML;

            // Reattach popup handlers after HTML update
            attachPopupHandlers(transcriptContent);

            // Auto-scroll to keep current subtitle visible (within transcript container only)
            if (centerIndex >= 0) {
                const currentEntry = transcriptContent.querySelector(`[data-index="${centerIndex}"]`);
                if (currentEntry) {
                    // Calculate scroll position to center the current entry in the transcript container
                    const containerRect = transcriptContent.getBoundingClientRect();
                    const entryRect = currentEntry.getBoundingClientRect();
                    const containerHeight = transcriptContent.clientHeight;
                    const entryHeight = currentEntry.offsetHeight;

                    // Calculate target scroll position to center the entry
                    const targetScrollTop = transcriptContent.scrollTop +
                        (entryRect.top - containerRect.top) -
                        (containerHeight / 2) +
                        (entryHeight / 2);

                    // Smooth scroll only within the transcript container
                    transcriptContent.scrollTo({
                        top: Math.max(0, targetScrollTop),
                        behavior: 'smooth'
                    });
                }
            }

            // Show the parse button if not yet parsed
            if (!transcriptParsed) {
                generateBtn.classList.remove('hidden');
            } else {
                generateBtn.classList.add('hidden');
            }
        }

        function updateTranscriptDisplay(centerIndex = 0) {
            const transcriptContent = document.getElementById('transcriptContent');
            const transcriptData = JSON.parse(transcriptContent.dataset.fullTranscript || '{}');

            if (!transcriptData.subtitles) return;

            const { subtitles, highlights } = transcriptData;

            // Create transcript HTML for ALL subtitles (allow scrolling through entire transcript)
            let transcriptHTML = '';

            for (let i = 0; i < subtitles.length; i++) {
                const subtitle = subtitles[i];
                if (!subtitle.text.trim()) continue;

                const isCurrent = (i === centerIndex);
                const bgClass = isCurrent ? 'bg-yellow-100 border-yellow-400' : 'bg-white border-blue-300';

                transcriptHTML += `<div class="subtitle-entry mb-2 p-2 rounded border-l-3 ${bgClass}" data-start="${subtitle.start}" data-end="${subtitle.end}" data-index="${i}">`;
                transcriptHTML += `<div class="text-xs text-gray-500 mb-1">${formatTime(subtitle.start)}</div>`;

                // Use pre-computed highlighting
                const highlightedText = highlights[i] || subtitle.text;
                transcriptHTML += `<div class="subtitle-text text-xs">${highlightedText}</div>`;
                transcriptHTML += '</div>';
            }

            transcriptContent.innerHTML = transcriptHTML;

            // Reattach popup handlers after HTML update
            attachPopupHandlers(transcriptContent);

            // Auto-scroll to keep current subtitle visible (within transcript container only)
            if (centerIndex >= 0) {
                const currentEntry = transcriptContent.querySelector(`[data-index="${centerIndex}"]`);
                if (currentEntry) {
                    // Calculate scroll position to center the current entry in the transcript container
                    const containerRect = transcriptContent.getBoundingClientRect();
                    const entryRect = currentEntry.getBoundingClientRect();
                    const containerHeight = transcriptContent.clientHeight;
                    const entryHeight = currentEntry.offsetHeight;

                    // Calculate target scroll position to center the entry
                    const targetScrollTop = transcriptContent.scrollTop +
                        (entryRect.top - containerRect.top) -
                        (containerHeight / 2) +
                        (entryHeight / 2);

                    // Smooth scroll only within the transcript container
                    transcriptContent.scrollTo({
                        top: Math.max(0, targetScrollTop),
                        behavior: 'smooth'
                    });
                }
            }
        }

        function generateHighlightsFromParseData(subtitleData, parseData, fullTranscript) {
            // Use existing parseData to generate highlights without additional API calls
            const highlights = [];
            let currentPosition = 0; // Track position in fullTranscript

            for (let i = 0; i < subtitleData.length; i++) {
                const subtitle = subtitleData[i];
                const subtitleText = subtitle.text.trim();

                if (!subtitleText) {
                    highlights[i] = subtitle.text;
                    continue;
                }

                // Find tokens that belong to this subtitle
                const subtitleTokens = parseData.tokens.filter(token => {
                    const tokenStart = token[1];
                    const tokenEnd = tokenStart + token[2];
                    return tokenStart >= currentPosition && tokenEnd <= currentPosition + subtitleText.length;
                });

                // Apply highlighting to this subtitle
                let highlightedText = subtitleText;
                const sortedTokens = subtitleTokens
                    .filter(token => token[0] >= 0) // Has vocabulary
                    .sort((a, b) => b[1] - a[1]); // Sort by position (reverse order to avoid offset issues)

                for (const token of sortedTokens) {
                    const vocabIndex = token[0];
                    const startPos = token[1] - currentPosition;
                    const length = token[2];

                    if (vocabIndex >= 0 && vocabIndex < parseData.vocabulary.length) {
                        const vocab = parseData.vocabulary[vocabIndex];
                        const vid = vocab[0]; // vid
                        const sid = vocab[1]; // sid
                        const spelling = vocab[3] || ''; // Spelling
                        const reading = vocab[4] || ''; // Reading
                        const meanings = vocab[7]?.flat() || []; // Meanings
                        const cardState = vocab[9]; // Card state

                        // Get proper state class for coloring
                        const stateClass = getStateClass(cardState);
                        const highlightClass = `vocab-highlight vocab-${stateClass}`;

                        // Create unique vocab ID and store data for popup functionality
                        const vocabId = `vocab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        vocabDataRegistry.set(vocabId, {
                            vocabId: vocabId,  // Store vocabId for retrieval
                            vid: vid,       // Store vid for API calls
                            sid: sid,       // Store sid for API calls
                            spelling: spelling,
                            reading: reading,
                            meanings: meanings,
                            card_state: cardState,
                            sourceText: subtitleText  // Store subtitle as sentence (usually already one sentence)
                        });

                        // Create tooltip text
                        const tooltip = `${spelling}: ${reading} [${meanings.slice(0, 2).join(', ')}]`;

                        // Apply highlighting with proper color coding
                        const before = highlightedText.substring(0, startPos);
                        const word = highlightedText.substring(startPos, startPos + length);
                        const after = highlightedText.substring(startPos + length);

                        highlightedText = `${before}<span class="${highlightClass}" data-vocab-id="${vocabId}" title="${tooltip}" style="cursor: pointer; display: inline-block; margin: 0px 1px;">${word}</span>${after}`;
                    }
                }

                highlights[i] = highlightedText;
                currentPosition += subtitleText.length + 1; // +1 for space between subtitles
            }

            return highlights;
        }

        async function generateAllSubtitleHighlights(subtitleData, parseData) {
            // PERFORMANCE: Create a single temporary container for all subtitle processing
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px';
            tempContainer.style.top = '-9999px';
            document.body.appendChild(tempContainer);

            const highlights = [];
            const batchSize = 10; // Process 10 subtitles at a time

            for (let batchStart = 0; batchStart < subtitleData.length; batchStart += batchSize) {
                const batchEnd = Math.min(batchStart + batchSize, subtitleData.length);
                const batchPromises = [];

                // Create batch elements
                for (let i = batchStart; i < batchEnd; i++) {
                    const subtitle = subtitleData[i];
                    if (!subtitle.text.trim()) {
                        highlights[i] = subtitle.text;
                        continue;
                    }

                    const subtitleDiv = document.createElement('div');
                    subtitleDiv.textContent = subtitle.text;
                    subtitleDiv.setAttribute('data-subtitle-index', i);
                    tempContainer.appendChild(subtitleDiv);

                    // Process this subtitle
                    const paragraphs = paragraphsInNode(subtitleDiv);
                    if (paragraphs.length > 0) {
                        const [batches, applied] = parseParagraphs(paragraphs);
                        const promise = Promise.allSettled(applied).then(() => {
                            highlights[i] = subtitleDiv.innerHTML;
                            tempContainer.removeChild(subtitleDiv);
                        });
                        batchPromises.push(promise);
                    } else {
                        highlights[i] = subtitle.text;
                        tempContainer.removeChild(subtitleDiv);
                    }
                }

                // Wait for this batch to complete
                await Promise.allSettled(batchPromises);
            }

            // Clean up
            document.body.removeChild(tempContainer);

            return highlights;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        function searchTranscript() {
            const searchTerm = prompt('Enter text to search in transcript:');
            if (!searchTerm || !searchTerm.trim()) return;

            // Search through all subtitle data (not just visible elements)
            let foundIndex = -1;
            for (let i = 0; i < subtitleData.length; i++) {
                if (subtitleData[i].text.toLowerCase().includes(searchTerm.toLowerCase())) {
                    foundIndex = i;
                    break;
                }
            }

            if (foundIndex >= 0) {
                // Update display to center on found subtitle
                updateTranscriptDisplay(foundIndex);

                // Highlight the found subtitle temporarily
                setTimeout(() => {
                    const transcriptContent = document.getElementById('transcriptContent');
                    const currentEntry = transcriptContent.querySelector('.bg-yellow-100');
                    if (currentEntry) {
                        currentEntry.style.boxShadow = '0 0 10px rgba(255, 193, 7, 0.5)';
                        setTimeout(() => {
                            currentEntry.style.boxShadow = '';
                        }, 3000);
                    }
                }, 100);

                console.log(`Found "${searchTerm}" in subtitle ${foundIndex + 1}`);
            } else {
                alert(`Text "${searchTerm}" not found in transcript`);
            }
        }

        // Global function for onclick
        window.addToDeck = addToDeck;

        // ===== iPad Touch Gestures & Apple Pencil Support =====

        // Touch gesture state
        let touchState = {
            isPinching: false,
            initialDistance: 0,
            initialScale: 1,
            lastTap: 0,
            touchStartX: 0,
            touchStartY: 0,
            isApplePencil: false
        };

        // ===== PWA & iPad A16 Performance Optimization =====

        // Performance monitoring for iPad A16 optimization
        let performanceMetrics = {
            loadTime: 0,
            memoryUsage: 0,
            isOnline: navigator.onLine,
            isPWA: false,
            deviceInfo: {}
        };

        // Detect if running as PWA
        function detectPWA() {
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
            const isIOSPWA = (window.navigator.standalone === true);
            performanceMetrics.isPWA = isStandalone || isIOSPWA;

            if (performanceMetrics.isPWA) {
                console.log('üçé Running as PWA on iPad');
                document.body.classList.add('pwa-mode');

                // Add PWA-specific optimizations
                optimizeForPWA();
            }
        }

        // iPad A16 and PWA optimizations
        function optimizeForPWA() {
            // Hardware acceleration for smooth animations
            document.body.style.transform = 'translateZ(0)';
            document.body.style.backfaceVisibility = 'hidden';
            document.body.style.perspective = '1000px';

            // Optimize for iPad A16 GPU
            const style = document.createElement('style');
            style.textContent = `
                * {
                    -webkit-transform: translateZ(0);
                    transform: translateZ(0);
                }

                .vocab-highlight {
                    will-change: background-color;
                    contain: layout style paint;
                }

                video, canvas {
                    will-change: transform;
                    contain: layout style paint;
                }

                .transcript-content {
                    contain: layout;
                }
            `;
            document.head.appendChild(style);

            // Preload critical resources
            const criticalResources = [
                'https://cdn.tailwindcss.com',
                'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'
            ];

            // Preload scripts
            criticalResources.forEach(url => {
                const link = document.createElement('link');
                link.rel = 'preload';
                link.href = url;
                link.as = 'script';
                link.crossOrigin = 'anonymous';
                document.head.appendChild(link);
            });

            // Prefetch main HTML (can't preload HTML documents)
            const htmlLink = document.createElement('link');
            htmlLink.rel = 'prefetch';
            htmlLink.href = '/demo.html';
            document.head.appendChild(htmlLink);
        }

        // Offline detection and handling
        function setupOfflineDetection() {
            window.addEventListener('online', () => {
                performanceMetrics.isOnline = true;
                console.log('üåê Back online');
                showStatus('Back online', 'success');

                // Sync any pending operations
                syncPendingOperations();
            });

            window.addEventListener('offline', () => {
                performanceMetrics.isOnline = false;
                console.log('üì¥ Gone offline');
                showStatus('Offline mode - cached content available', 'info');
            });

            // Check connection quality
            if ('connection' in navigator) {
                const connection = navigator.connection;
                console.log(`üì° Connection: ${connection.effectiveType}, ${connection.downlink}Mbps`);

                connection.addEventListener('change', () => {
                    console.log(`üì° Connection changed: ${connection.effectiveType}, ${connection.downlink}Mbps`);
                });
            }
        }

        // Performance monitoring
        function monitorPerformance() {
            // Measure initial load time
            window.addEventListener('load', () => {
                performanceMetrics.loadTime = performance.now();
                console.log(`‚ö° Initial load time: ${performanceMetrics.loadTime.toFixed(2)}ms`);

                // Monitor memory usage if available
                if ('memory' in performance) {
                    const memInfo = performance.memory;
                    performanceMetrics.memoryUsage = memInfo.usedJSHeapSize;
                    console.log(`üß† Memory usage: ${(memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
                }
            });

            // Monitor long tasks (for iPad A16 optimization)
            if ('PerformanceObserver' in window && 'supportedEntryTypes' in PerformanceObserver) {
                // Check if longtask is supported before attempting to observe
                if (PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('longtask')) {
                    try {
                        const observer = new PerformanceObserver((list) => {
                            for (const entry of list.getEntries()) {
                                if (entry.duration > 50) { // Tasks longer than 50ms
                                    console.warn(`‚ö†Ô∏è Long task detected: ${entry.duration.toFixed(2)}ms`);
                                }
                            }
                        });
                        observer.observe({ entryTypes: ['longtask'] });
                        console.log('‚úÖ Long task monitoring enabled');
                    } catch (e) {
                        console.log('Long task monitoring failed:', e);
                    }
                } else {
                    console.log('‚ÑπÔ∏è Long task monitoring not supported in this browser');
                }
            }
        }

        // Device detection for iPad A16 optimization
        function detectDevice() {
            const ua = navigator.userAgent;
            const deviceInfo = {
                isIPad: /iPad/.test(ua) || (/Macintosh/.test(ua) && 'ontouchend' in document),
                isIOS: /iPad|iPhone|iPod/.test(ua),
                isSafari: /^((?!chrome|android).)*safari/i.test(ua),
                isChrome: /Chrome/.test(ua),
                screenWidth: screen.width,
                screenHeight: screen.height,
                pixelRatio: window.devicePixelRatio || 1,
                touchPoints: navigator.maxTouchPoints || 0
            };

            performanceMetrics.deviceInfo = deviceInfo;

            console.log('üì± Device Info:', deviceInfo);

            // iPad-specific optimizations
            if (deviceInfo.isIPad) {
                console.log('üçé iPad detected - applying optimizations');

                // Disable iOS bounce scrolling
                document.body.style.overscrollBehavior = 'none';
                document.documentElement.style.overscrollBehavior = 'none';

                // Optimize touch handling
                document.body.style.touchAction = 'manipulation';

                // Add iPad-specific CSS
                const ipadCSS = document.createElement('style');
                ipadCSS.textContent = `
                    /* iPad-specific optimizations */
                    * {
                        -webkit-touch-callout: none;
                        -webkit-user-select: text;
                        user-select: text;
                    }

                    .transcript-content {
                        -webkit-overflow-scrolling: touch;
                        overscroll-behavior: contain;
                    }

                    /* Optimize for iPad Pro displays */
                    @media (min-width: 1024px) {
                        body {
                            font-size: 16px;
                        }

                        button {
                            min-height: 48px;
                            min-width: 48px;
                        }
                    }
                `;
                document.head.appendChild(ipadCSS);
            }

            return deviceInfo;
        }

        // Sync pending operations when back online
        function syncPendingOperations() {
            // Could implement syncing of pending operations here
            // For now, just ensure cached data is up to date
            console.log('üîÑ Syncing pending operations...');

            // Refresh cache if needed
            if (Object.keys(jpdbCache).length > 0) {
                console.log('üíæ Cache contains', Object.keys(jpdbCache).length, 'entries');
            }
        }

        // PWA installation prompt for iPad
        let deferredPrompt;
        function setupPWAInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent the mini-infobar from appearing on mobile
                e.preventDefault();
                // Stash the event so it can be triggered later
                deferredPrompt = e;

                // Show custom install button for iPad
                if (performanceMetrics.deviceInfo.isIPad) {
                    showInstallPrompt();
                }
            });

            // Handle successful installation
            window.addEventListener('appinstalled', () => {
                console.log('üçé PWA installed successfully');
                showStatus('App installed! You can now use JPDB Reader offline.', 'success');
                deferredPrompt = null;
            });
        }

        function showInstallPrompt() {
            const installBtn = document.createElement('button');
            installBtn.innerHTML = 'üì± Install JPDB Reader';
            installBtn.className = 'fixed bottom-4 right-4 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg shadow-lg z-50';
            installBtn.onclick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`üçé User ${outcome} the install prompt`);
                    deferredPrompt = null;
                }
                installBtn.remove();
            };

            document.body.appendChild(installBtn);

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (installBtn.parentNode) {
                    installBtn.remove();
                }
            }, 10000);
        }

        // Apple Pencil detection and touch gesture handling
        function initTouchGestures() {
            console.log('üéØ Initializing iPad touch gestures and Apple Pencil support');

            // PDF viewer pinch-to-zoom
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                setupPinchZoom(pdfViewer);
            }

            // Video player swipe navigation
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer) {
                setupSwipeNavigation(videoPlayer);
            }

            // Transcript scroll with momentum
            const transcriptContent = document.getElementById('transcriptContent');
            if (transcriptContent) {
                setupTranscriptTouchScroll(transcriptContent);
            }

            // EPUB reader touch navigation
            const epubReader = document.getElementById('epubReader');
            if (epubReader) {
                setupEpubTouchNavigation(epubReader);
            }

            // Apple Pencil drawing support
            setupApplePencilSupport();

            // Touch-optimized controls
            setupTouchControls();
        }

        // Pinch-to-zoom for PDF viewer
        function setupPinchZoom(element) {
            let initialDistance = 0;
            let initialScale = 1;

            element.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    touchState.isPinching = true;

                    // Calculate initial distance between touches
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // Store initial scale
                    initialScale = element.style.transform ?
                        parseFloat(element.style.transform.match(/scale\(([^)]+)\)/)?.[1] || 1) : 1;
                }
            });

            element.addEventListener('touchmove', (e) => {
                if (touchState.isPinching && e.touches.length === 2) {
                    e.preventDefault();

                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // Calculate new scale
                    const scale = initialScale * (currentDistance / initialDistance);
                    const clampedScale = Math.min(Math.max(scale, 0.5), 3.0); // Limit zoom 0.5x to 3.0x

                    // Apply transform
                    element.style.transform = `scale(${clampedScale})`;
                    element.style.transformOrigin = 'center center';
                }
            });

            element.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    touchState.isPinching = false;
                }
            });
        }

        // Swipe navigation for video player
        function setupSwipeNavigation(videoElement) {
            let startX = 0;
            let startY = 0;
            let isSwipe = false;

            videoElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    isSwipe = true;
                }
            });

            videoElement.addEventListener('touchmove', (e) => {
                if (!isSwipe || e.touches.length !== 1) return;

                const deltaX = e.touches[0].clientX - startX;
                const deltaY = e.touches[0].clientY - startY;

                // Only consider horizontal swipes (more significant than vertical)
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    e.preventDefault();

                    if (deltaX > 0) {
                        // Swipe right - seek backward 10 seconds
                        videoElement.currentTime = Math.max(0, videoElement.currentTime - 10);
                        showStatus('‚è™ Seek backward 10s', 'info');
                    } else {
                        // Swipe left - seek forward 10 seconds
                        videoElement.currentTime = Math.min(videoElement.duration || videoElement.currentTime + 10, videoElement.currentTime + 10);
                        showStatus('‚è© Seek forward 10s', 'info');
                    }

                    isSwipe = false; // Prevent multiple seeks per swipe
                }
            });

            videoElement.addEventListener('touchend', () => {
                isSwipe = false;
            });
        }

        // Enhanced transcript scrolling with momentum
        function setupTranscriptTouchScroll(element) {
            let startY = 0;
            let scrollTop = 0;
            let momentum = 0;
            let lastY = 0;
            let lastTime = 0;

            element.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                scrollTop = element.scrollTop;
                momentum = 0;
                lastY = startY;
                lastTime = Date.now();
            });

            element.addEventListener('touchmove', (e) => {
                if (e.touches.length !== 1) return;

                const currentY = e.touches[0].clientY;
                const deltaY = startY - currentY;

                // Calculate momentum for smooth scrolling
                const currentTime = Date.now();
                const timeDelta = currentTime - lastTime;
                if (timeDelta > 0) {
                    const velocity = (lastY - currentY) / timeDelta;
                    momentum = velocity * 0.8; // Damping factor
                }

                // Apply scroll
                element.scrollTop = scrollTop + deltaY;

                lastY = currentY;
                lastTime = currentTime;
            });

            // Apply momentum scrolling
            element.addEventListener('touchend', () => {
                if (Math.abs(momentum) > 0.1) {
                    const applyMomentum = () => {
                        element.scrollTop += momentum;
                        momentum *= 0.95; // Deceleration

                        if (Math.abs(momentum) > 0.1) {
                            requestAnimationFrame(applyMomentum);
                        }
                    };
                    requestAnimationFrame(applyMomentum);
                }
            });
        }

        // EPUB touch navigation
        function setupEpubTouchNavigation(element) {
            let startX = 0;
            let startY = 0;

            element.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                }
            });

            element.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1) {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const deltaX = startX - endX;
                    const deltaY = startY - endY;

                    // Detect swipe direction (horizontal swipes for page navigation)
                    if (Math.abs(deltaX) > 100 && Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0) {
                            // Swipe left - next page
                            showStatus('üìÑ Next page', 'info');
                            // Trigger next page if function exists
                            if (window.nextEpubPage) window.nextEpubPage();
                        } else {
                            // Swipe right - previous page
                            showStatus('üìÑ Previous page', 'info');
                            // Trigger previous page if function exists
                            if (window.prevEpubPage) window.prevEpubPage();
                        }
                    }
                }
            });
        }

        // Apple Pencil detection and support
        function setupApplePencilSupport() {
            // Detect Apple Pencil by checking for force touch and stylus properties
            document.addEventListener('pointerdown', (e) => {
                // Check if it's likely an Apple Pencil
                if (e.pointerType === 'pen' ||
                    (e.pressure > 0 && e.pressure !== 0.5) ||
                    e.tangentialPressure !== undefined) {
                    touchState.isApplePencil = true;
                    console.log('üçé Apple Pencil detected');

                    // Could add drawing/highlighting features here
                    // For now, just enhance pointer interactions
                    e.target.style.cursor = 'crosshair';
                }
            });

            document.addEventListener('pointerup', () => {
                touchState.isApplePencil = false;
                document.body.style.cursor = '';
            });

            // Enhanced pressure sensitivity for Apple Pencil
            document.addEventListener('pointermove', (e) => {
                if (touchState.isApplePencil && e.pressure > 0) {
                    // Could implement pressure-sensitive drawing
                    // For now, just log pressure for debugging
                    if (e.pressure > 0.8) {
                        console.log('üçé High pressure detected:', e.pressure);
                    }
                }
            });
        }

        // Touch-optimized controls for tablets
        function setupTouchControls() {
            // Make buttons larger on touch devices
            if ('ontouchstart' in window) {
                console.log('üì± Touch device detected - optimizing controls');

                const buttons = document.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.minHeight = '44px'; // iOS recommended minimum
                    button.style.minWidth = '44px';
                    button.style.touchAction = 'manipulation'; // Prevent double-tap zoom
                });

                // Add touch feedback
                buttons.forEach(button => {
                    button.addEventListener('touchstart', () => {
                        button.style.transform = 'scale(0.95)';
                        button.style.transition = 'transform 0.1s';
                    });

                    button.addEventListener('touchend', () => {
                        button.style.transform = 'scale(1)';
                    });
                });

                // Increase font sizes for better touch readability
                const textElements = document.querySelectorAll('p, span, div');
                textElements.forEach(el => {
                    const currentSize = window.getComputedStyle(el).fontSize;
                    const sizeValue = parseFloat(currentSize);
                    if (sizeValue < 16) {
                        el.style.fontSize = Math.max(sizeValue * 1.2, 16) + 'px';
                    }
                });
            }

            // Double-tap to pause/play video
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer) {
                videoPlayer.addEventListener('touchend', (e) => {
                    const currentTime = Date.now();
                    const tapLength = currentTime - touchState.lastTap;

                    if (tapLength < 300 && tapLength > 0) {
                        // Double tap detected
                        e.preventDefault();
                        if (videoPlayer.paused) {
                            videoPlayer.play();
                            showStatus('‚ñ∂Ô∏è Play', 'success');
                        } else {
                            videoPlayer.pause();
                            showStatus('‚è∏Ô∏è Pause', 'info');
                        }
                    }

                    touchState.lastTap = currentTime;
                });
            }

            // Add visual feedback for touch interactions
            const interactiveElements = document.querySelectorAll('button, .vocab-highlight, [role="button"]');
            interactiveElements.forEach(el => {
                el.addEventListener('touchstart', () => {
                    el.style.opacity = '0.7';
                });

                el.addEventListener('touchend', () => {
                    el.style.opacity = '1';
                });
            });
        }

        // Initialize all optimizations when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // PWA and device detection
            detectPWA();
            detectDevice();
            setupPWAInstallPrompt();

            // Performance monitoring
            monitorPerformance();
            setupOfflineDetection();

            // Touch gestures (includes Apple Pencil support)
            initTouchGestures();

            // Load saved deck selection
            loadSavedDeckSelection();
        });
    </script>
</body>
</html>
